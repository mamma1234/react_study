{"version":3,"file":"immer.umd.js","sources":["../src/types.ts","../src/common.ts","../src/scope.ts","../src/es5.ts","../src/proxy.ts","../src/patches.ts","../src/map.ts","../src/set.ts","../src/finalize.ts","../src/immer.ts","../src/index.ts"],"sourcesContent":["import {Nothing, DRAFT_STATE} from \"./common\"\nimport {SetState} from \"./set\"\nimport {MapState} from \"./map\"\nimport {ProxyObjectState, ProxyArrayState} from \"./proxy\"\nimport {ES5ObjectState, ES5ArrayState} from \"./es5\"\nimport {ImmerScope} from \"./scope\"\n\nexport type Objectish = AnyObject | AnyArray | AnyMap | AnySet\nexport type ObjectishNoSet = AnyObject | AnyArray | AnyMap\n\nexport type AnyObject = {[key: string]: any}\nexport type AnyArray = Array<any>\nexport type AnySet = Set<any>\nexport type AnyMap = Map<any, any>\nexport enum Archtype {\n\tObject,\n\tArray,\n\tMap,\n\tSet\n}\n\nexport enum ProxyType {\n\tProxyObject,\n\tProxyArray,\n\tES5Object,\n\tES5Array,\n\tMap,\n\tSet\n}\n\nexport interface ImmerBaseState {\n\tparent?: ImmerState\n\tscope: ImmerScope\n\tmodified: boolean\n\tfinalized: boolean\n\tisManual: boolean\n}\n\nexport type ImmerState =\n\t| ProxyObjectState\n\t| ProxyArrayState\n\t| ES5ObjectState\n\t| ES5ArrayState\n\t| MapState\n\t| SetState\n\n// The _internal_ type used for drafts (not to be confused with Draft, which is public facing)\nexport type Drafted<Base = any, T extends ImmerState = ImmerState> = {\n\t[DRAFT_STATE]: T\n} & Base\n\ntype Tail<T extends any[]> = ((...t: T) => any) extends (\n\t_: any,\n\t...tail: infer TT\n) => any\n\t? TT\n\t: []\n\n/** Object types that should never be mapped */\ntype AtomicObject =\n\t| Function\n\t| WeakMap<any, any>\n\t| WeakSet<any>\n\t| Promise<any>\n\t| Date\n\t| RegExp\n\t| Boolean\n\t| Number\n\t| String\n\nexport type Draft<T> = T extends AtomicObject\n\t? T\n\t: T extends Map<infer K, infer V>\n\t? DraftMap<K, V>\n\t: T extends Set<infer V>\n\t? DraftSet<V>\n\t: T extends object\n\t? {-readonly [K in keyof T]: Draft<T[K]>}\n\t: T\n\n// Inline these in ts 3.7\ninterface DraftMap<K, V> extends Map<Draft<K>, Draft<V>> {}\n\n// Inline these in ts 3.7\ninterface DraftSet<V> extends Set<Draft<V>> {}\n\n/** Convert a mutable type into a readonly type */\nexport type Immutable<T> = T extends AtomicObject\n\t? T\n\t: T extends Map<infer K, infer V> // Ideally, but wait for TS 3.7:    ? Omit<ImmutableMap<K, V>, \"set\" | \"delete\" | \"clear\">\n\t? ImmutableMap<K, V>\n\t: T extends Set<infer V> // Ideally, but wait for TS 3.7:    ? Omit<ImmutableSet<V>, \"add\" | \"delete\" | \"clear\">\n\t? ImmutableSet<V>\n\t: T extends object\n\t? {readonly [K in keyof T]: Immutable<T[K]>}\n\t: T\n\ninterface ImmutableMap<K, V> extends Map<Immutable<K>, Immutable<V>> {}\n\ninterface ImmutableSet<V> extends Set<Immutable<V>> {}\n\nexport interface Patch {\n\top: \"replace\" | \"remove\" | \"add\"\n\tpath: (string | number)[]\n\tvalue?: any\n}\n\nexport type PatchListener = (patches: Patch[], inversePatches: Patch[]) => void\n\n/** Converts `nothing` into `undefined` */\ntype FromNothing<T> = T extends Nothing ? undefined : T\n\n/** The inferred return type of `produce` */\nexport type Produced<Base, Return> = Return extends void\n\t? Base\n\t: Return extends Promise<infer Result>\n\t? Promise<Result extends void ? Base : FromNothing<Result>>\n\t: FromNothing<Return>\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport interface IProduce {\n\t/** Curried producer */\n\t<\n\t\tRecipe extends (...args: any[]) => any,\n\t\tParams extends any[] = Parameters<Recipe>,\n\t\tT = Params[0]\n\t>(\n\t\trecipe: Recipe\n\t): <Base extends Immutable<T>>(\n\t\tbase: Base,\n\t\t...rest: Tail<Params>\n\t) => Produced<Base, ReturnType<Recipe>>\n\t//   ^ by making the returned type generic, the actual type of the passed in object is preferred\n\t//     over the type used in the recipe. However, it does have to satisfy the immutable version used in the recipe\n\t//     Note: the type of S is the widened version of T, so it can have more props than T, but that is technically actually correct!\n\n\t/** Curried producer with initial state */\n\t<\n\t\tRecipe extends (...args: any[]) => any,\n\t\tParams extends any[] = Parameters<Recipe>,\n\t\tT = Params[0]\n\t>(\n\t\trecipe: Recipe,\n\t\tinitialState: Immutable<T>\n\t): <Base extends Immutable<T>>(\n\t\tbase?: Base,\n\t\t...rest: Tail<Params>\n\t) => Produced<Base, ReturnType<Recipe>>\n\n\t/** Normal producer */\n\t<Base, D = Draft<Base>, Return = void>(\n\t\tbase: Base,\n\t\trecipe: (draft: D) => Return,\n\t\tlistener?: PatchListener\n\t): Produced<Base, Return>\n}\n\n/**\n * Like `produce`, but instead of just returning the new state,\n * a tuple is returned with [nextState, patches, inversePatches]\n *\n * Like produce, this function supports currying\n */\nexport interface IProduceWithPatches {\n\t/** Curried producer */\n\t<\n\t\tRecipe extends (...args: any[]) => any,\n\t\tParams extends any[] = Parameters<Recipe>,\n\t\tT = Params[0]\n\t>(\n\t\trecipe: Recipe\n\t): <Base extends Immutable<T>>(\n\t\tbase: Base,\n\t\t...rest: Tail<Params>\n\t) => [Produced<Base, ReturnType<Recipe>>, Patch[], Patch[]]\n\t//   ^ by making the returned type generic, the actual type of the passed in object is preferred\n\t//     over the type used in the recipe. However, it does have to satisfy the immutable version used in the recipe\n\t//     Note: the type of S is the widened version of T, so it can have more props than T, but that is technically actually correct!\n\n\t/** Curried producer with initial state */\n\t<\n\t\tRecipe extends (...args: any[]) => any,\n\t\tParams extends any[] = Parameters<Recipe>,\n\t\tT = Params[0]\n\t>(\n\t\trecipe: Recipe,\n\t\tinitialState: Immutable<T>\n\t): <Base extends Immutable<T>>(\n\t\tbase?: Base,\n\t\t...rest: Tail<Params>\n\t) => [Produced<Base, ReturnType<Recipe>>, Patch[], Patch[]]\n\n\t/** Normal producer */\n\t<Base, D = Draft<Base>, Return = void>(\n\t\tbase: Base,\n\t\trecipe: (draft: D) => Return\n\t): [Produced<Base, Return>, Patch[], Patch[]]\n}\n","import {\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\tProxyType,\n\tArchtype\n} from \"./types\"\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n\nconst hasSymbol = typeof Symbol !== \"undefined\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\nexport const iteratorSymbol: typeof Symbol.iterator = hasSymbol\n\t? Symbol.iterator\n\t: (\"@@iterator\" as any)\n\n/** Returns true if the given value is an Immer draft */\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\treturn !proto || proto === Object.prototype\n}\n\n/** Get the underlying object that is represented by the given draft */\nexport function original<T>(value: Drafted<T>): T | undefined {\n\tif (value && value[DRAFT_STATE]) {\n\t\treturn value[DRAFT_STATE].base as any\n\t}\n\t// otherwise return undefined\n}\n\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void\n): void\nexport function each(obj: any, iter: any) {\n\tif (getArchtype(obj) === Archtype.Object) {\n\t\townKeys(obj).forEach(key => iter(key, obj[key], obj))\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\nexport function isEnumerable(base: AnyObject, prop: PropertyKey): boolean {\n\tconst desc = Object.getOwnPropertyDescriptor(base, prop)\n\treturn desc && desc.enumerable ? true : false\n}\n\nexport function getArchtype(thing: any): Archtype {\n\t/* istanbul ignore next */\n\tif (!thing) die()\n\tif (thing[DRAFT_STATE]) {\n\t\tswitch ((thing as Drafted)[DRAFT_STATE].type) {\n\t\t\tcase ProxyType.ES5Object:\n\t\t\tcase ProxyType.ProxyObject:\n\t\t\t\treturn Archtype.Object\n\t\t\tcase ProxyType.ES5Array:\n\t\t\tcase ProxyType.ProxyArray:\n\t\t\t\treturn Archtype.Array\n\t\t\tcase ProxyType.Map:\n\t\t\t\treturn Archtype.Map\n\t\t\tcase ProxyType.Set:\n\t\t\t\treturn Archtype.Set\n\t\t}\n\t}\n\treturn Array.isArray(thing)\n\t\t? Archtype.Array\n\t\t: isMap(thing)\n\t\t? Archtype.Map\n\t\t: isSet(thing)\n\t\t? Archtype.Set\n\t\t: Archtype.Object\n}\n\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === Archtype.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop]\n}\n\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tswitch (getArchtype(thing)) {\n\t\tcase Archtype.Map:\n\t\t\tthing.set(propOrOldValue, value)\n\t\t\tbreak\n\t\tcase Archtype.Set:\n\t\t\tthing.delete(propOrOldValue)\n\t\t\tthing.add(value)\n\t\t\tbreak\n\t\tdefault:\n\t\t\tthing[propOrOldValue] = value\n\t}\n}\n\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n\nexport function latest(state: ImmerState): any {\n\treturn state.copy || state.base\n}\n\nexport function shallowCopy<T extends AnyObject | AnyArray>(\n\tbase: T,\n\tinvokeGetters?: boolean\n): T\nexport function shallowCopy(base: any, invokeGetters = false) {\n\tif (Array.isArray(base)) return base.slice()\n\tconst clone = Object.create(Object.getPrototypeOf(base))\n\townKeys(base).forEach(key => {\n\t\tif (key === DRAFT_STATE) {\n\t\t\treturn // Never copy over draft state.\n\t\t}\n\t\tconst desc = Object.getOwnPropertyDescriptor(base, key)!\n\t\tlet {value} = desc\n\t\tif (desc.get) {\n\t\t\tif (!invokeGetters) {\n\t\t\t\tthrow new Error(\"Immer drafts cannot have computed properties\")\n\t\t\t}\n\t\t\tvalue = desc.get.call(base)\n\t\t}\n\t\tif (desc.enumerable) {\n\t\t\tclone[key] = value\n\t\t} else {\n\t\t\tObject.defineProperty(clone, key, {\n\t\t\t\tvalue,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true\n\t\t\t})\n\t\t}\n\t})\n\treturn clone\n}\n\nexport function freeze(obj: any, deep: boolean): void {\n\tif (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) return\n\tconst type = getArchtype(obj)\n\tif (type === Archtype.Set) {\n\t\tobj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t} else if (type === Archtype.Map) {\n\t\tobj.set = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (_, value) => freeze(value, true))\n}\n\nfunction dontMutateFrozenCollections() {\n\tthrow new Error(\"This object has been frozen and should not be mutated\")\n}\n\nexport function createHiddenProperty(\n\ttarget: AnyObject,\n\tprop: PropertyKey,\n\tvalue: any\n) {\n\tObject.defineProperty(target, prop, {\n\t\tvalue: value,\n\t\tenumerable: false,\n\t\twritable: true\n\t})\n}\n\n/* istanbul ignore next */\nexport function die(): never {\n\tthrow new Error(\"Illegal state, please file a bug\")\n}\n","import {DRAFT_STATE} from \"./common\"\nimport {Patch, PatchListener, Drafted, ProxyType} from \"./types\"\nimport {Immer} from \"./immer\"\n\n/** Each scope represents a `produce` call. */\nexport class ImmerScope {\n\tstatic current?: ImmerScope\n\n\tpatches?: Patch[]\n\tinversePatches?: Patch[]\n\tcanAutoFreeze: boolean\n\tdrafts: any[]\n\tparent?: ImmerScope\n\tpatchListener?: PatchListener\n\timmer: Immer\n\n\tconstructor(parent: ImmerScope | undefined, immer: Immer) {\n\t\tthis.drafts = []\n\t\tthis.parent = parent\n\t\tthis.immer = immer\n\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tthis.canAutoFreeze = true\n\t}\n\n\tusePatches(patchListener?: PatchListener) {\n\t\tif (patchListener) {\n\t\t\tthis.patches = []\n\t\t\tthis.inversePatches = []\n\t\t\tthis.patchListener = patchListener\n\t\t}\n\t}\n\n\trevoke() {\n\t\tthis.leave()\n\t\tthis.drafts.forEach(revoke)\n\t\t// @ts-ignore\n\t\tthis.drafts = null\n\t}\n\n\tleave() {\n\t\tif (this === ImmerScope.current) {\n\t\t\tImmerScope.current = this.parent\n\t\t}\n\t}\n\n\tstatic enter(immer: Immer) {\n\t\tconst scope = new ImmerScope(ImmerScope.current, immer)\n\t\tImmerScope.current = scope\n\t\treturn scope\n\t}\n}\n\nfunction revoke(draft: Drafted) {\n\tconst state = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type === ProxyType.ProxyObject ||\n\t\tstate.type === ProxyType.ProxyArray\n\t)\n\t\tstate.revoke()\n\telse state.revoked = true\n}\n","\"use strict\"\nimport {\n\teach,\n\thas,\n\tis,\n\tisDraft,\n\tisDraftable,\n\tisEnumerable,\n\tshallowCopy,\n\tDRAFT_STATE,\n\tlatest,\n\tcreateHiddenProperty\n} from \"./common\"\n\nimport {ImmerScope} from \"./scope\"\nimport {\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tObjectish,\n\tImmerBaseState,\n\tAnyArray,\n\tProxyType\n} from \"./types\"\nimport {MapState} from \"./map\"\nimport {SetState} from \"./set\"\n\ninterface ES5BaseState extends ImmerBaseState {\n\tfinalizing: boolean\n\tassigned: {[key: string]: any}\n\tparent?: ImmerState\n\trevoked: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype: ProxyType.ES5Object\n\tdraft: Drafted<AnyObject, ES5ObjectState>\n\tbase: AnyObject\n\tcopy: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype: ProxyType.ES5Array\n\tdraft: Drafted<AnyObject, ES5ArrayState>\n\tbase: AnyArray\n\tcopy: AnyArray | null\n}\n\ntype ES5State = ES5ArrayState | ES5ObjectState\n\nexport function willFinalizeES5(\n\tscope: ImmerScope,\n\tresult: any,\n\tisReplaced: boolean\n) {\n\tscope.drafts!.forEach(draft => {\n\t\tdraft[DRAFT_STATE].finalizing = true\n\t})\n\tif (!isReplaced) {\n\t\tif (scope.patches) {\n\t\t\tmarkChangesRecursively(scope.drafts![0])\n\t\t}\n\t\t// This is faster when we don't care about which attributes changed.\n\t\tmarkChangesSweep(scope.drafts)\n\t}\n\t// When a child draft is returned, look for changes.\n\telse if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n\t\tmarkChangesSweep(scope.drafts)\n\t}\n}\n\nexport function createES5Proxy<T>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ES5ObjectState | ES5ArrayState> {\n\tconst isArray = Array.isArray(base)\n\tconst draft = clonePotentialDraft(base)\n\n\teach(draft, prop => {\n\t\tproxyProperty(draft, prop, isArray || isEnumerable(base, prop))\n\t})\n\n\tconst state: ES5ObjectState | ES5ArrayState = {\n\t\ttype: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\n\t\tscope: parent ? parent.scope : ImmerScope.current!,\n\t\tmodified: false,\n\t\tfinalizing: false,\n\t\tfinalized: false,\n\t\tassigned: {},\n\t\tparent,\n\t\tbase,\n\t\tdraft,\n\t\tcopy: null,\n\t\trevoked: false,\n\t\tisManual: false\n\t}\n\n\tcreateHiddenProperty(draft, DRAFT_STATE, state)\n\treturn draft\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tif (state && !state.finalizing) {\n\t\tstate.finalizing = true\n\t\tconst value = draft[prop]\n\t\tstate.finalizing = false\n\t\treturn value\n\t}\n\treturn draft[prop]\n}\n\nfunction get(state: ES5State, prop: string | number) {\n\tassertUnrevoked(state)\n\tconst value = peek(latest(state), prop)\n\tif (state.finalizing) return value\n\t// Create a draft if the value is unmodified.\n\tif (value === peek(state.base, prop) && isDraftable(value)) {\n\t\tprepareCopy(state)\n\t\t// @ts-ignore\n\t\treturn (state.copy![prop] = state.scope.immer.createProxy(value, state))\n\t}\n\treturn value\n}\n\nfunction set(state: ES5State, prop: string | number, value: any) {\n\tassertUnrevoked(state)\n\tstate.assigned[prop] = true\n\tif (!state.modified) {\n\t\tif (is(value, peek(latest(state), prop))) return\n\t\tmarkChangedES5(state)\n\t\tprepareCopy(state)\n\t}\n\t// @ts-ignore\n\tstate.copy![prop] = value\n}\n\nexport function markChangedES5(state: ImmerState) {\n\tif (!state.modified) {\n\t\tstate.modified = true\n\t\tif (state.parent) markChangedES5(state.parent)\n\t}\n}\n\nfunction prepareCopy(state: ES5State) {\n\tif (!state.copy) state.copy = clonePotentialDraft(state.base)\n}\n\nfunction clonePotentialDraft(base: Objectish) {\n\tconst state = base && (base as any)[DRAFT_STATE]\n\tif (state) {\n\t\tstate.finalizing = true\n\t\tconst draft = shallowCopy(state.draft, true)\n\t\tstate.finalizing = false\n\t\treturn draft\n\t}\n\treturn shallowCopy(base)\n}\n\n// property descriptors are recycled to make sure we don't create a get and set closure per property,\n// but share them all instead\nconst descriptors: {[prop: string]: PropertyDescriptor} = {}\n\nfunction proxyProperty(\n\tdraft: Drafted<any, ES5State>,\n\tprop: string | number,\n\tenumerable: boolean\n) {\n\tlet desc = descriptors[prop]\n\tif (desc) {\n\t\tdesc.enumerable = enumerable\n\t} else {\n\t\tdescriptors[prop] = desc = {\n\t\t\tconfigurable: true,\n\t\t\tenumerable,\n\t\t\tget(this: any) {\n\t\t\t\treturn get(this[DRAFT_STATE], prop)\n\t\t\t},\n\t\t\tset(this: any, value) {\n\t\t\t\tset(this[DRAFT_STATE], prop, value)\n\t\t\t}\n\t\t}\n\t}\n\tObject.defineProperty(draft, prop, desc)\n}\n\nexport function assertUnrevoked(state: ES5State | MapState | SetState) {\n\tif (state.revoked === true)\n\t\tthrow new Error(\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\t\tJSON.stringify(latest(state))\n\t\t)\n}\n\n// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\nfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\n\t// The natural order of drafts in the `scope` array is based on when they\n\t// were accessed. By processing drafts in reverse natural order, we have a\n\t// better chance of processing leaf nodes first. When a leaf node is known to\n\t// have changed, we can avoid any traversal of its ancestor nodes.\n\tfor (let i = drafts.length - 1; i >= 0; i--) {\n\t\tconst state = drafts[i][DRAFT_STATE]\n\t\tif (!state.modified) {\n\t\t\tswitch (state.type) {\n\t\t\t\tcase ProxyType.ES5Array:\n\t\t\t\t\tif (hasArrayChanges(state)) markChangedES5(state)\n\t\t\t\t\tbreak\n\t\t\t\tcase ProxyType.ES5Object:\n\t\t\t\t\tif (hasObjectChanges(state)) markChangedES5(state)\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction markChangesRecursively(object: any) {\n\tif (!object || typeof object !== \"object\") return\n\tconst state = object[DRAFT_STATE]\n\tif (!state) return\n\tconst {base, draft, assigned, type} = state\n\tif (type === ProxyType.ES5Object) {\n\t\t// Look for added keys.\n\t\t// TODO: looks quite duplicate to hasObjectChanges,\n\t\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\n\t\t// unnecessary work.\n\t\t// also: probably we can store the information we detect here, to speed up tree finalization!\n\t\teach(draft, key => {\n\t\t\tif ((key as any) === DRAFT_STATE) return\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (base[key] === undefined && !has(base, key)) {\n\t\t\t\tassigned[key] = true\n\t\t\t\tmarkChangedES5(state)\n\t\t\t} else if (!assigned[key]) {\n\t\t\t\t// Only untouched properties trigger recursion.\n\t\t\t\tmarkChangesRecursively(draft[key])\n\t\t\t}\n\t\t})\n\t\t// Look for removed keys.\n\t\teach(base, key => {\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (draft[key] === undefined && !has(draft, key)) {\n\t\t\t\tassigned[key] = false\n\t\t\t\tmarkChangedES5(state)\n\t\t\t}\n\t\t})\n\t} else if (type === ProxyType.ES5Array && hasArrayChanges(state)) {\n\t\tmarkChangedES5(state)\n\t\tassigned.length = true\n\t\tif (draft.length < base.length) {\n\t\t\tfor (let i = draft.length; i < base.length; i++) assigned[i] = false\n\t\t} else {\n\t\t\tfor (let i = base.length; i < draft.length; i++) assigned[i] = true\n\t\t}\n\t\tfor (let i = 0; i < draft.length; i++) {\n\t\t\t// Only untouched indices trigger recursion.\n\t\t\tif (assigned[i] === undefined) markChangesRecursively(draft[i])\n\t\t}\n\t}\n}\n\nfunction hasObjectChanges(state: ES5ObjectState) {\n\tconst {base, draft} = state\n\n\t// Search for added keys and changed keys. Start at the back, because\n\t// non-numeric keys are ordered by time of definition on the object.\n\tconst keys = Object.keys(draft)\n\tfor (let i = keys.length - 1; i >= 0; i--) {\n\t\tconst key = keys[i]\n\t\tconst baseValue = base[key]\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (baseValue === undefined && !has(base, key)) {\n\t\t\treturn true\n\t\t}\n\t\t// Once a base key is deleted, future changes go undetected, because its\n\t\t// descriptor is erased. This branch detects any missed changes.\n\t\telse {\n\t\t\tconst value = draft[key]\n\t\t\tconst state = value && value[DRAFT_STATE]\n\t\t\tif (state ? state.base !== baseValue : !is(value, baseValue)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\n\t// At this point, no keys were added or changed.\n\t// Compare key count to determine if keys were deleted.\n\treturn keys.length !== Object.keys(base).length\n}\n\nfunction hasArrayChanges(state: ES5ArrayState) {\n\tconst {draft} = state\n\tif (draft.length !== state.base.length) return true\n\t// See #116\n\t// If we first shorten the length, our array interceptors will be removed.\n\t// If after that new items are added, result in the same original length,\n\t// those last items will have no intercepting property.\n\t// So if there is no own descriptor on the last position, we know that items were removed and added\n\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n\t// the last one\n\tconst descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1)\n\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\tif (descriptor && !descriptor.get) return true\n\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\treturn false\n}\n","\"use strict\"\nimport {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tDRAFT_STATE,\n\tlatest\n} from \"./common\"\nimport {ImmerScope} from \"./scope\"\nimport {\n\tAnyObject,\n\tDrafted,\n\tImmerState,\n\tAnyArray,\n\tObjectish,\n\tImmerBaseState,\n\tProxyType\n} from \"./types\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned: {\n\t\t[property: string]: boolean\n\t}\n\tparent?: ImmerState\n\tdrafts?: {\n\t\t[property: string]: Drafted<any, any>\n\t}\n\trevoke(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype: ProxyType.ProxyObject\n\tbase: AnyObject\n\tcopy: AnyObject | null\n\tdraft: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype: ProxyType.ProxyArray\n\tbase: AnyArray\n\tcopy: AnyArray | null\n\tdraft: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope: parent ? parent.scope : ImmerScope.current!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified: false,\n\t\t// Used during finalization.\n\t\tfinalized: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned: {},\n\t\t// The parent draft state.\n\t\tparent,\n\t\t// The base state.\n\t\tbase,\n\t\t// The base proxy.\n\t\tdraft: null as any, // set below\n\t\t// Any property proxies.\n\t\tdrafts: {},\n\t\t// The base copy with any updated values.\n\t\tcopy: null,\n\t\t// Called by the `produce` function.\n\t\trevoke: null as any,\n\t\tisManual: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\t// TODO: optimization: might be faster, cheaper if we created a non-revocable proxy\n\t// and administrate revoking ourselves\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft = proxy as any\n\tstate.revoke = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nconst objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\t\tlet {drafts} = state\n\n\t\t// Check for existing draft in unmodified state.\n\t\tif (!state.modified && has(drafts, prop)) {\n\t\t\treturn drafts![prop as any]\n\t\t}\n\n\t\tconst value = latest(state)[prop]\n\t\tif (state.finalized || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\n\t\t// Check for existing draft in modified state.\n\t\tif (state.modified) {\n\t\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\t\tif (value !== peek(state.base, prop)) return value\n\t\t\t// Store drafts on the copy (when one exists).\n\t\t\t// @ts-ignore\n\t\t\tdrafts = state.copy\n\t\t}\n\n\t\treturn (drafts![prop as any] = state.scope.immer.createProxy(value, state))\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(state, prop: string /* strictly not, but helps TS */, value) {\n\t\tif (!state.modified) {\n\t\t\tconst baseValue = peek(state.base, prop)\n\t\t\t// Optimize based on value's truthiness. Truthy values are guaranteed to\n\t\t\t// never be undefined, so we can avoid the `in` operator. Lastly, truthy\n\t\t\t// values may be drafts, but falsy values are never drafts.\n\t\t\tconst isUnchanged = value\n\t\t\t\t? is(baseValue, value) || value === state.drafts![prop]\n\t\t\t\t: is(baseValue, value) && prop in state.base\n\t\t\tif (isUnchanged) return true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\t\tstate.assigned[prop] = true\n\t\t// @ts-ignore\n\t\tstate.copy![prop] = value\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base, prop) !== undefined || prop in state.base) {\n\t\t\tstate.assigned[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else if (state.assigned[prop]) {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy) delete state.copy[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (desc) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable =\n\t\t\t\tstate.type !== ProxyType.ProxyArray || prop !== \"length\"\n\t\t}\n\t\treturn desc\n\t},\n\tdefineProperty() {\n\t\tthrow new Error(\"Object.defineProperty() cannot be used on an Immer draft\") // prettier-ignore\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base)\n\t},\n\tsetPrototypeOf() {\n\t\tthrow new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\") // prettier-ignore\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (isNaN(parseInt(prop as any))) {\n\t\tthrow new Error(\"Immer only supports deleting array indices\") // prettier-ignore\n\t}\n\treturn objectTraps.deleteProperty!.call(this, state[0], prop)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (prop !== \"length\" && isNaN(parseInt(prop as any))) {\n\t\tthrow new Error(\"Immer only supports setting array indices and the 'length' property\") // prettier-ignore\n\t}\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n/**\n * Map drafts\n */\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey): any {\n\tconst state = draft[DRAFT_STATE]\n\tconst desc = Reflect.getOwnPropertyDescriptor(\n\t\tstate ? latest(state) : draft,\n\t\tprop\n\t)\n\treturn desc && desc.value\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified) {\n\t\tstate.modified = true\n\t\tif (\n\t\t\tstate.type === ProxyType.ProxyObject ||\n\t\t\tstate.type === ProxyType.ProxyArray\n\t\t) {\n\t\t\tconst copy = (state.copy = shallowCopy(state.base))\n\t\t\teach(state.drafts!, (key, value) => {\n\t\t\t\t// @ts-ignore\n\t\t\t\tcopy[key] = value\n\t\t\t})\n\t\t\tstate.drafts = undefined\n\t\t}\n\n\t\tif (state.parent) {\n\t\t\tmarkChanged(state.parent)\n\t\t}\n\t}\n}\n\nfunction prepareCopy(state: ProxyState) {\n\tif (!state.copy) {\n\t\tstate.copy = shallowCopy(state.base)\n\t}\n}\n","import {get, each, isMap, has, die, getArchtype} from \"./common\"\nimport {Patch, ImmerState, ProxyType, Archtype} from \"./types\"\nimport {SetState} from \"./set\"\nimport {ES5ArrayState, ES5ObjectState} from \"./es5\"\nimport {ProxyArrayState, ProxyObjectState} from \"./proxy\"\nimport {MapState} from \"./map\"\n\nexport type PatchPath = (string | number)[]\n\nexport function generatePatches(\n\tstate: ImmerState,\n\tbasePath: PatchPath,\n\tpatches: Patch[],\n\tinversePatches: Patch[]\n): void {\n\tswitch (state.type) {\n\t\tcase ProxyType.ProxyObject:\n\t\tcase ProxyType.ES5Object:\n\t\tcase ProxyType.Map:\n\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\tstate,\n\t\t\t\tbasePath,\n\t\t\t\tpatches,\n\t\t\t\tinversePatches\n\t\t\t)\n\t\tcase ProxyType.ES5Array:\n\t\tcase ProxyType.ProxyArray:\n\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\tcase ProxyType.Set:\n\t\t\treturn generateSetPatches(\n\t\t\t\t(state as any) as SetState,\n\t\t\t\tbasePath,\n\t\t\t\tpatches,\n\t\t\t\tinversePatches\n\t\t\t)\n\t}\n}\n\nfunction generateArrayPatches(\n\tstate: ES5ArrayState | ProxyArrayState,\n\tbasePath: PatchPath,\n\tpatches: Patch[],\n\tinversePatches: Patch[]\n) {\n\tlet {base, assigned, copy} = state\n\t/* istanbul ignore next */\n\tif (!copy) die()\n\n\t// Reduce complexity by ensuring `base` is never longer.\n\tif (copy.length < base.length) {\n\t\t// @ts-ignore\n\t\t;[base, copy] = [copy, base]\n\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t}\n\n\tconst delta = copy.length - base.length\n\n\t// Find the first replaced index.\n\tlet start = 0\n\twhile (base[start] === copy[start] && start < base.length) {\n\t\t++start\n\t}\n\n\t// Find the last replaced index. Search from the end to optimize splice patches.\n\tlet end = base.length\n\twhile (end > start && base[end - 1] === copy[end + delta - 1]) {\n\t\t--end\n\t}\n\n\t// Process replaced indices.\n\tfor (let i = start; i < end; ++i) {\n\t\tif (assigned[i] && copy[i] !== base[i]) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: \"replace\",\n\t\t\t\tpath,\n\t\t\t\tvalue: copy[i]\n\t\t\t})\n\t\t\tinversePatches.push({\n\t\t\t\top: \"replace\",\n\t\t\t\tpath,\n\t\t\t\tvalue: base[i]\n\t\t\t})\n\t\t}\n\t}\n\n\tconst replaceCount = patches.length\n\n\t// Process added indices.\n\tfor (let i = end + delta - 1; i >= end; --i) {\n\t\tconst path = basePath.concat([i])\n\t\tpatches[replaceCount + i - end] = {\n\t\t\top: \"add\",\n\t\t\tpath,\n\t\t\tvalue: copy[i]\n\t\t}\n\t\tinversePatches.push({\n\t\t\top: \"remove\",\n\t\t\tpath\n\t\t})\n\t}\n}\n\n// This is used for both Map objects and normal objects.\nfunction generatePatchesFromAssigned(\n\tstate: MapState | ES5ObjectState | ProxyObjectState,\n\tbasePath: PatchPath,\n\tpatches: Patch[],\n\tinversePatches: Patch[]\n) {\n\tconst {base, copy} = state\n\teach(state.assigned!, (key, assignedValue) => {\n\t\tconst origValue = get(base, key)\n\t\tconst value = get(copy!, key)\n\t\tconst op = !assignedValue ? \"remove\" : has(base, key) ? \"replace\" : \"add\"\n\t\tif (origValue === value && op === \"replace\") return\n\t\tconst path = basePath.concat(key as any)\n\t\tpatches.push(op === \"remove\" ? {op, path} : {op, path, value})\n\t\tinversePatches.push(\n\t\t\top === \"add\"\n\t\t\t\t? {op: \"remove\", path}\n\t\t\t\t: op === \"remove\"\n\t\t\t\t? {op: \"add\", path, value: origValue}\n\t\t\t\t: {op: \"replace\", path, value: origValue}\n\t\t)\n\t})\n}\n\nfunction generateSetPatches(\n\tstate: SetState,\n\tbasePath: PatchPath,\n\tpatches: Patch[],\n\tinversePatches: Patch[]\n) {\n\tlet {base, copy} = state\n\n\tlet i = 0\n\tbase.forEach(value => {\n\t\tif (!copy!.has(value)) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: \"remove\",\n\t\t\t\tpath,\n\t\t\t\tvalue\n\t\t\t})\n\t\t\tinversePatches.unshift({\n\t\t\t\top: \"add\",\n\t\t\t\tpath,\n\t\t\t\tvalue\n\t\t\t})\n\t\t}\n\t\ti++\n\t})\n\ti = 0\n\tcopy!.forEach(value => {\n\t\tif (!base.has(value)) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: \"add\",\n\t\t\t\tpath,\n\t\t\t\tvalue\n\t\t\t})\n\t\t\tinversePatches.unshift({\n\t\t\t\top: \"remove\",\n\t\t\t\tpath,\n\t\t\t\tvalue\n\t\t\t})\n\t\t}\n\t\ti++\n\t})\n}\n\nexport function applyPatches<T>(draft: T, patches: Patch[]): T {\n\tpatches.forEach(patch => {\n\t\tconst {path, op} = patch\n\n\t\t/* istanbul ignore next */\n\t\tif (!path.length) die()\n\n\t\tlet base: any = draft\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tbase = get(base, path[i])\n\t\t\tif (!base || typeof base !== \"object\")\n\t\t\t\tthrow new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\")) // prettier-ignore\n\t\t}\n\n\t\tconst type = getArchtype(base)\n\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\tconst key = path[path.length - 1]\n\t\tswitch (op) {\n\t\t\tcase \"replace\":\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\tthrow new Error('Sets cannot have \"replace\" patches.')\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t}\n\t\t\tcase \"add\":\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\treturn base.splice(key as any, 0, value)\n\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t}\n\t\t\tcase \"remove\":\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unsupported patch operation: \" + op)\n\t\t}\n\t})\n\n\treturn draft\n}\n\n// TODO: optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n// E.g. auto-draft when new objects from outside are assigned and modified?\n// (See failing test when deepClone just returns obj)\nfunction deepClonePatchValue<T>(obj: T): T\nfunction deepClonePatchValue(obj: any) {\n\tif (!obj || typeof obj !== \"object\") return obj\n\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\tif (isMap(obj))\n\t\treturn new Map(\n\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t)\n\t// Not needed: if (isSet(obj)) return new Set(Array.from(obj.values()).map(deepClone))\n\tconst cloned = Object.create(Object.getPrototypeOf(obj))\n\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\treturn cloned\n}\n","import {isDraftable, DRAFT_STATE, latest, iteratorSymbol} from \"./common\"\n\nimport {ImmerScope} from \"./scope\"\nimport {AnyMap, Drafted, ImmerState, ImmerBaseState, ProxyType} from \"./types\"\nimport {assertUnrevoked} from \"./es5\"\n\nexport interface MapState extends ImmerBaseState {\n\ttype: ProxyType.Map\n\tcopy: AnyMap | undefined\n\tassigned: Map<any, boolean> | undefined\n\tbase: AnyMap\n\trevoked: boolean\n\tdraft: Drafted<AnyMap, MapState>\n}\n\n// Make sure DraftMap declarion doesn't die if Map is not avialable...\n/* istanbul ignore next */\nconst MapBase: MapConstructor =\n\ttypeof Map !== \"undefined\" ? Map : (function FakeMap() {} as any)\n\nexport class DraftMap<K, V> extends MapBase implements Map<K, V> {\n\t[DRAFT_STATE]: MapState\n\tconstructor(target: AnyMap, parent?: ImmerState) {\n\t\tsuper()\n\t\tthis[DRAFT_STATE] = {\n\t\t\ttype: ProxyType.Map,\n\t\t\tparent,\n\t\t\tscope: parent ? parent.scope : ImmerScope.current!,\n\t\t\tmodified: false,\n\t\t\tfinalized: false,\n\t\t\tcopy: undefined,\n\t\t\tassigned: undefined,\n\t\t\tbase: target,\n\t\t\tdraft: this,\n\t\t\tisManual: false,\n\t\t\trevoked: false\n\t\t}\n\t}\n\n\tget size(): number {\n\t\treturn latest(this[DRAFT_STATE]).size\n\t}\n\n\thas(key: K): boolean {\n\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t}\n\n\tset(key: K, value: V): this {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tif (latest(state).get(key) !== value) {\n\t\t\tprepareCopy(state)\n\t\t\tstate.scope.immer.markChanged(state)\n\t\t\tstate.assigned!.set(key, true)\n\t\t\tstate.copy!.set(key, value)\n\t\t\tstate.assigned!.set(key, true)\n\t\t}\n\t\treturn this\n\t}\n\n\tdelete(key: K): boolean {\n\t\tif (!this.has(key)) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tprepareCopy(state)\n\t\tstate.scope.immer.markChanged(state)\n\t\tstate.assigned!.set(key, false)\n\t\tstate.copy!.delete(key)\n\t\treturn true\n\t}\n\n\tclear() {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tprepareCopy(state)\n\t\tstate.scope.immer.markChanged(state)\n\t\tstate.assigned = new Map()\n\t\tfor (const key of latest(state).keys()) {\n\t\t\tstate.assigned.set(key, false)\n\t\t}\n\t\treturn state.copy!.clear()\n\t}\n\n\tforEach(cb: (value: V, key: K, self: this) => void, thisArg?: any) {\n\t\tconst state = this[DRAFT_STATE]\n\t\tlatest(state).forEach((_value: V, key: K, _map: this) => {\n\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t})\n\t}\n\n\tget(key: K): V {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tconst value = latest(state).get(key)\n\t\tif (state.finalized || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\tif (value !== state.base.get(key)) {\n\t\t\treturn value // either already drafted or reassigned\n\t\t}\n\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\tconst draft = state.scope.immer.createProxy(value, state)\n\t\tprepareCopy(state)\n\t\tstate.copy!.set(key, draft)\n\t\treturn draft\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\treturn latest(this[DRAFT_STATE]).keys()\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\tconst iterator = this.keys()\n\t\treturn {\n\t\t\t[iteratorSymbol]: () => this.values(),\n\t\t\tnext: () => {\n\t\t\t\tconst r = iterator.next()\n\t\t\t\t/* istanbul ignore next */\n\t\t\t\tif (r.done) return r\n\t\t\t\tconst value = this.get(r.value)\n\t\t\t\treturn {\n\t\t\t\t\tdone: false,\n\t\t\t\t\tvalue\n\t\t\t\t}\n\t\t\t}\n\t\t} as any\n\t}\n\n\tentries(): IterableIterator<[K, V]> {\n\t\tconst iterator = this.keys()\n\t\treturn {\n\t\t\t[iteratorSymbol]: () => this.entries(),\n\t\t\tnext: () => {\n\t\t\t\tconst r = iterator.next()\n\t\t\t\t/* istanbul ignore next */\n\t\t\t\tif (r.done) return r\n\t\t\t\tconst value = this.get(r.value)\n\t\t\t\treturn {\n\t\t\t\t\tdone: false,\n\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t}\n\t\t\t}\n\t\t} as any\n\t}\n\n\t[iteratorSymbol]() {\n\t\treturn this.entries()\n\t}\n}\n\nexport function proxyMap(target: AnyMap, parent?: ImmerState) {\n\treturn new DraftMap(target, parent)\n}\n\nfunction prepareCopy(state: MapState) {\n\tif (!state.copy) {\n\t\tstate.assigned = new Map()\n\t\tstate.copy = new Map(state.base)\n\t}\n}\n","import {DRAFT_STATE, latest, isDraftable, iteratorSymbol} from \"./common\"\n\nimport {ImmerScope} from \"./scope\"\nimport {AnySet, Drafted, ImmerState, ImmerBaseState, ProxyType} from \"./types\"\nimport {assertUnrevoked} from \"./es5\"\n\nexport interface SetState extends ImmerBaseState {\n\ttype: ProxyType.Set\n\tcopy: AnySet | undefined\n\tbase: AnySet\n\tdrafts: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked: boolean\n\tdraft: Drafted<AnySet, SetState>\n}\n\n// Make sure DraftSet declarion doesn't die if Map is not avialable...\n/* istanbul ignore next */\nconst SetBase: SetConstructor =\n\ttypeof Set !== \"undefined\" ? Set : (function FakeSet() {} as any)\n\nexport class DraftSet<K, V> extends SetBase implements Set<V> {\n\t[DRAFT_STATE]: SetState\n\tconstructor(target: AnySet, parent?: ImmerState) {\n\t\tsuper()\n\t\tthis[DRAFT_STATE] = {\n\t\t\ttype: ProxyType.Set,\n\t\t\tparent,\n\t\t\tscope: parent ? parent.scope : ImmerScope.current!,\n\t\t\tmodified: false,\n\t\t\tfinalized: false,\n\t\t\tcopy: undefined,\n\t\t\tbase: target,\n\t\t\tdraft: this,\n\t\t\tdrafts: new Map(),\n\t\t\trevoked: false,\n\t\t\tisManual: false\n\t\t}\n\t}\n\n\tget size(): number {\n\t\treturn latest(this[DRAFT_STATE]).size\n\t}\n\n\thas(value: V): boolean {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\tif (!state.copy) {\n\t\t\treturn state.base.has(value)\n\t\t}\n\t\tif (state.copy.has(value)) return true\n\t\tif (state.drafts.has(value) && state.copy.has(state.drafts.get(value)))\n\t\t\treturn true\n\t\treturn false\n\t}\n\n\tadd(value: V): this {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tif (state.copy) {\n\t\t\tstate.copy.add(value)\n\t\t} else if (!state.base.has(value)) {\n\t\t\tprepareCopy(state)\n\t\t\tstate.scope.immer.markChanged(state)\n\t\t\tstate.copy!.add(value)\n\t\t}\n\t\treturn this\n\t}\n\n\tdelete(value: V): boolean {\n\t\tif (!this.has(value)) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tprepareCopy(state)\n\t\tstate.scope.immer.markChanged(state)\n\t\treturn (\n\t\t\tstate.copy!.delete(value) ||\n\t\t\t(state.drafts.has(value)\n\t\t\t\t? state.copy!.delete(state.drafts.get(value))\n\t\t\t\t: /* istanbul ignore next */ false)\n\t\t)\n\t}\n\n\tclear() {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tprepareCopy(state)\n\t\tstate.scope.immer.markChanged(state)\n\t\treturn state.copy!.clear()\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tprepareCopy(state)\n\t\treturn state.copy!.values()\n\t}\n\n\tentries(): IterableIterator<[V, V]> {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tprepareCopy(state)\n\t\treturn state.copy!.entries()\n\t}\n\n\tkeys(): IterableIterator<V> {\n\t\treturn this.values()\n\t}\n\n\t[iteratorSymbol]() {\n\t\treturn this.values()\n\t}\n\n\tforEach(cb: (value: V, key: V, self: this) => void, thisArg?: any) {\n\t\tconst iterator = this.values()\n\t\tlet result = iterator.next()\n\t\twhile (!result.done) {\n\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\tresult = iterator.next()\n\t\t}\n\t}\n}\n\nexport function proxySet(target: AnySet, parent?: ImmerState) {\n\treturn new DraftSet(target, parent)\n}\n\nfunction prepareCopy(state: SetState) {\n\tif (!state.copy) {\n\t\t// create drafts for all entries to preserve insertion order\n\t\tstate.copy = new Set()\n\t\tstate.base.forEach(value => {\n\t\t\tif (isDraftable(value)) {\n\t\t\t\tconst draft = state.scope.immer.createProxy(value, state)\n\t\t\t\tstate.drafts.set(value, draft)\n\t\t\t\tstate.copy!.add(draft)\n\t\t\t} else {\n\t\t\t\tstate.copy!.add(value)\n\t\t\t}\n\t\t})\n\t}\n}\n","import {Immer} from \"./immer\"\nimport {ImmerState, Drafted, ProxyType} from \"./types\"\nimport {ImmerScope} from \"./scope\"\nimport {\n\tisSet,\n\thas,\n\tis,\n\tget,\n\teach,\n\tDRAFT_STATE,\n\tNOTHING,\n\tfreeze,\n\tshallowCopy,\n\tset\n} from \"./common\"\nimport {isDraft, isDraftable} from \"./index\"\nimport {SetState} from \"./set\"\nimport {generatePatches, PatchPath} from \"./patches\"\n\nexport function processResult(immer: Immer, result: any, scope: ImmerScope) {\n\tconst baseDraft = scope.drafts![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\timmer.willFinalize(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified) {\n\t\t\tscope.revoke()\n\t\t\tthrow new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\") // prettier-ignore\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(immer, result, scope)\n\t\t\tmaybeFreeze(immer, result)\n\t\t}\n\t\tif (scope.patches) {\n\t\t\tscope.patches.push({\n\t\t\t\top: \"replace\",\n\t\t\t\tpath: [],\n\t\t\t\tvalue: result\n\t\t\t})\n\t\t\tscope.inversePatches!.push({\n\t\t\t\top: \"replace\",\n\t\t\t\tpath: [],\n\t\t\t\tvalue: baseDraft[DRAFT_STATE].base\n\t\t\t})\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(immer, baseDraft, scope, [])\n\t}\n\tscope.revoke()\n\tif (scope.patches) {\n\t\tscope.patchListener!(scope.patches, scope.inversePatches!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(\n\timmer: Immer,\n\tdraft: Drafted,\n\tscope: ImmerScope,\n\tpath?: PatchPath\n) {\n\tconst state = draft[DRAFT_STATE]\n\tif (!state) {\n\t\tif (Object.isFrozen(draft)) return draft\n\t\treturn finalizeTree(immer, draft, scope)\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope !== scope) {\n\t\treturn draft\n\t}\n\tif (!state.modified) {\n\t\tmaybeFreeze(immer, state.base, true)\n\t\treturn state.base\n\t}\n\tif (!state.finalized) {\n\t\tstate.finalized = true\n\t\tfinalizeTree(immer, state.draft, scope, path)\n\n\t\t// We cannot really delete anything inside of a Set. We can only replace the whole Set.\n\t\tif (immer.onDelete && state.type !== ProxyType.Set) {\n\t\t\t// The `assigned` object is unreliable with ES5 drafts.\n\t\t\tif (immer.useProxies) {\n\t\t\t\tconst {assigned} = state\n\t\t\t\teach(assigned, (prop, exists) => {\n\t\t\t\t\tif (!exists) immer.onDelete!(state, prop as any)\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tconst {base, copy} = state\n\t\t\t\teach(base, prop => {\n\t\t\t\t\tif (!has(copy, prop)) immer.onDelete!(state, prop as any)\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tif (immer.onCopy) {\n\t\t\timmer.onCopy(state)\n\t\t}\n\n\t\t// At this point, all descendants of `state.copy` have been finalized,\n\t\t// so we can be sure that `scope.canAutoFreeze` is accurate.\n\t\tif (immer.autoFreeze && scope.canAutoFreeze) {\n\t\t\tfreeze(state.copy, false)\n\t\t}\n\n\t\tif (path && scope.patches) {\n\t\t\tgeneratePatches(state, path, scope.patches, scope.inversePatches!)\n\t\t}\n\t}\n\treturn state.copy\n}\n\nfunction finalizeTree(\n\timmer: Immer,\n\troot: Drafted,\n\tscope: ImmerScope,\n\trootPath?: PatchPath\n) {\n\tconst state = root[DRAFT_STATE]\n\tif (state) {\n\t\tif (\n\t\t\tstate.type === ProxyType.ES5Object ||\n\t\t\tstate.type === ProxyType.ES5Array\n\t\t) {\n\t\t\t// Create the final copy, with added keys and without deleted keys.\n\t\t\tstate.copy = shallowCopy(state.draft, true)\n\t\t}\n\t\troot = state.copy\n\t}\n\teach(root, (key, value) =>\n\t\tfinalizeProperty(immer, scope, root, state, root, key, value, rootPath)\n\t)\n\treturn root\n}\n\nfunction finalizeProperty(\n\timmer: Immer,\n\tscope: ImmerScope,\n\troot: Drafted,\n\trootState: ImmerState,\n\tparentValue: Drafted,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (childValue === parentValue) {\n\t\tthrow Error(\"Immer forbids circular references\")\n\t}\n\n\t// In the `finalizeTree` method, only the `root` object may be a draft.\n\tconst isDraftProp = !!rootState && parentValue === root\n\tconst isSetMember = isSet(parentValue)\n\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tisDraftProp &&\n\t\t\t!isSetMember && // Set objects are atomic since they have no keys.\n\t\t\t!has((rootState as Exclude<ImmerState, SetState>).assigned!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tchildValue = finalize(immer, childValue, scope, path)\n\t\tset(parentValue, prop, childValue)\n\n\t\t// Drafts from another scope must prevent auto-freezing.\n\t\tif (isDraft(childValue)) {\n\t\t\tscope.canAutoFreeze = false\n\t\t}\n\t}\n\t// Unchanged draft properties are ignored.\n\telse if (isDraftProp && is(childValue, get(rootState.base, prop))) {\n\t\treturn\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\t// TODO: the recursion over here looks weird, shouldn't non-draft stuff have it's own recursion?\n\t// especially the passing on of root and rootState doesn't make sense...\n\telse if (isDraftable(childValue) && !Object.isFrozen(childValue)) {\n\t\teach(childValue, (key, grandChild) =>\n\t\t\tfinalizeProperty(\n\t\t\t\timmer,\n\t\t\t\tscope,\n\t\t\t\troot,\n\t\t\t\trootState,\n\t\t\t\tchildValue,\n\t\t\t\tkey,\n\t\t\t\tgrandChild,\n\t\t\t\trootPath\n\t\t\t)\n\t\t)\n\t\tmaybeFreeze(immer, childValue)\n\t}\n\n\tif (isDraftProp && immer.onAssign && !isSetMember) {\n\t\timmer.onAssign(rootState, prop, childValue)\n\t}\n}\n\nexport function maybeFreeze(immer: Immer, value: any, deep = false) {\n\tif (immer.autoFreeze && !isDraft(value)) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {createES5Proxy, willFinalizeES5, markChangedES5} from \"./es5\"\nimport {createProxy, markChanged} from \"./proxy\"\n\nimport {applyPatches} from \"./patches\"\nimport {\n\teach,\n\tisDraft,\n\tisSet,\n\tisMap,\n\tisDraftable,\n\tDRAFT_STATE,\n\tNOTHING,\n\tdie\n} from \"./common\"\nimport {ImmerScope} from \"./scope\"\nimport {\n\tImmerState,\n\tIProduce,\n\tIProduceWithPatches,\n\tObjectish,\n\tPatchListener,\n\tDraft,\n\tPatch,\n\tDrafted\n} from \"./types\"\nimport {proxyMap} from \"./map\"\nimport {proxySet} from \"./set\"\nimport {processResult, maybeFreeze} from \"./finalize\"\n\n/* istanbul ignore next */\nfunction verifyMinified() {}\n\nconst configDefaults = {\n\tuseProxies:\n\t\ttypeof Proxy !== \"undefined\" &&\n\t\ttypeof Proxy.revocable !== \"undefined\" &&\n\t\ttypeof Reflect !== \"undefined\",\n\tautoFreeze:\n\t\ttypeof process !== \"undefined\"\n\t\t\t? process.env.NODE_ENV !== \"production\"\n\t\t\t: /* istanbul ignore next */\n\t\t\t  verifyMinified.name === \"verifyMinified\",\n\tonAssign: null,\n\tonDelete: null,\n\tonCopy: null\n} as const\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies: boolean = false\n\tautoFreeze: boolean = false\n\tonAssign?: (state: ImmerState, prop: string | number, value: unknown) => void\n\tonDelete?: (state: ImmerState, prop: string | number) => void\n\tonCopy?: (state: ImmerState) => void\n\n\tconstructor(config?: {\n\t\tuseProxies?: boolean\n\t\tautoFreeze?: boolean\n\t\tonAssign?: (\n\t\t\tstate: ImmerState,\n\t\t\tprop: string | number,\n\t\t\tvalue: unknown\n\t\t) => void\n\t\tonDelete?: (state: ImmerState, prop: string | number) => void\n\t\tonCopy?: (state: ImmerState) => void\n\t}) {\n\t\teach(configDefaults, (key, value) => {\n\t\t\t// @ts-ignore\n\t\t\tthis[key] = config?.[key] ?? value\n\t\t})\n\t\tthis.setUseProxies(this.useProxies)\n\t\tthis.produce = this.produce.bind(this)\n\t\tthis.produceWithPatches = this.produceWithPatches.bind(this)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce(base: any, recipe?: any, patchListener?: any) {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\t// prettier-ignore\n\t\t{\n\t\t\tif (typeof recipe !== \"function\") {\n\t\t\t\tthrow new Error(\"The first or second argument to `produce` must be a function\")\n\t\t\t}\n\t\t\tif (patchListener !== undefined && typeof patchListener !== \"function\") {\n\t\t\t\tthrow new Error(\"The third argument to `produce` must be a function or undefined\")\n\t\t\t}\n\t\t}\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = ImmerScope.enter(this)\n\t\t\tconst proxy = this.createProxy(base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) scope.revoke()\n\t\t\t\telse scope.leave()\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tscope.usePatches(patchListener)\n\t\t\t\t\t\treturn processResult(this, result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\tscope.revoke()\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tscope.usePatches(patchListener)\n\t\t\treturn processResult(this, result, scope)\n\t\t} else {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === NOTHING) return undefined\n\t\t\tif (result === undefined) result = base\n\t\t\tmaybeFreeze(this, result, true)\n\t\t\treturn result\n\t\t}\n\t}\n\n\tproduceWithPatches(arg1: any, arg2?: any, arg3?: any): any {\n\t\tif (typeof arg1 === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\n\t\t}\n\t\t// non-curried form\n\t\t/* istanbul ignore next */\n\t\tif (arg3) die()\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst nextState = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [nextState, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Drafted<T> {\n\t\tif (!isDraftable(base)) {\n\t\t\tthrow new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\") // prettier-ignore\n\t\t}\n\t\tconst scope = ImmerScope.enter(this)\n\t\tconst proxy = this.createProxy(base, undefined)\n\t\tproxy[DRAFT_STATE].isManual = true\n\t\tscope.leave()\n\t\treturn proxy\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && draft[DRAFT_STATE]\n\t\tif (!state || !state.isManual) {\n\t\t\tthrow new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\") // prettier-ignore\n\t\t}\n\t\tif (state.finalized) {\n\t\t\tthrow new Error(\"The given draft is already finalized\") // prettier-ignore\n\t\t}\n\t\tconst {scope} = state\n\t\tscope.usePatches(patchListener)\n\t\treturn processResult(this, undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is disabled in production.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tthis.useProxies = value\n\t}\n\n\tapplyPatches(base: Objectish, patches: Patch[]) {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatches(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatches(draft, patches.slice(i + 1))\n\t\t)\n\t}\n\n\tcreateProxy<T extends Objectish>(\n\t\tvalue: T,\n\t\tparent?: ImmerState\n\t): Drafted<T, ImmerState> {\n\t\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\t\tconst draft: Drafted = isMap(value)\n\t\t\t? proxyMap(value, parent)\n\t\t\t: isSet(value)\n\t\t\t? proxySet(value, parent)\n\t\t\t: this.useProxies\n\t\t\t? createProxy(value, parent)\n\t\t\t: createES5Proxy(value, parent)\n\n\t\tconst scope = parent ? parent.scope : ImmerScope.current!\n\t\tscope.drafts.push(draft)\n\t\treturn draft\n\t}\n\n\twillFinalize(scope: ImmerScope, thing: any, isReplaced: boolean) {\n\t\tif (!this.useProxies) willFinalizeES5(scope, thing, isReplaced)\n\t}\n\n\tmarkChanged(state: ImmerState) {\n\t\tif (this.useProxies) {\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\tmarkChangedES5(state)\n\t\t}\n\t}\n}\n","import {Immer} from \"./immer\"\nimport {IProduce, IProduceWithPatches} from \"./types\"\n\nexport {Draft, Immutable, Patch, PatchListener} from \"./types\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\nexport {\n\toriginal,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable\n} from \"./common\"\n\nexport {Immer}\n"],"names":["Archtype","ProxyType","const","hasSymbol","Symbol","hasMap","Map","hasSet","Set","NOTHING","DRAFTABLE","DRAFT_STATE","iteratorSymbol","iterator","isDraft","value","isDraftable","proto","Object","getPrototypeOf","prototype","isPlainObject","Array","isArray","constructor","isMap","isSet","ownKeys","Reflect","getOwnPropertySymbols","obj","getOwnPropertyNames","concat","each","iter","getArchtype","forEach","key","entry","index","thing","die","type","ES5Object","ProxyObject","ES5Array","ProxyArray","has","prop","hasOwnProperty","call","get","is","x","y","target","latest","state","copy","base","shallowCopy","invokeGetters","slice","clone","create","desc","getOwnPropertyDescriptor","Error","enumerable","defineProperty","writable","configurable","freeze","deep","isFrozen","add","clear","delete","dontMutateFrozenCollections","set","_","ImmerScope","parent","immer","drafts","canAutoFreeze","revoke","draft","revoked","willFinalizeES5","scope","result","isReplaced","finalizing","markChangesSweep","patches","markChangesRecursively","object","assigned","undefined","markChangedES5","hasArrayChanges","length","let","i","createES5Proxy","clonePotentialDraft","descriptors","assertUnrevoked","peek","prepareCopy","createProxy","this","modified","proxyProperty","isEnumerable","current","finalized","isManual","usePatches","patchListener","inversePatches","leave","enter","JSON","stringify","hasObjectChanges","keys","baseValue","descriptor","objectTraps","markChanged","deleteProperty","owner","setPrototypeOf","arrayTraps","generatePatches","basePath","assignedValue","origValue","op","path","push","generatePatchesFromAssigned","delta","start","end","replaceCount","generateArrayPatches","unshift","generateSetPatches","applyPatches","patch","join","deepClonePatchValue","splice","map","from","entries","ref","cloned","fn","arguments","apply","isNaN","parseInt","DraftMap","size","cb","thisArg","_value","_map","values","next","r","done","DraftSet","processResult","baseDraft","willFinalize","maybeFreeze","finalize","finalizeTree","onDelete","useProxies","exists","onCopy","autoFreeze","root","rootPath","finalizeProperty","rootState","parentValue","childValue","isDraftProp","isSetMember","propOrOldValue","grandChild","onAssign","configDefaults","Proxy","revocable","process","env","NODE_ENV","name","Immer","config","setUseProxies","produce","bind","produceWithPatches","recipe","defaultBase","self","args","proxy","hasError","Promise","then","error","arg1","arg2","arg3","p","ip","createDraft","finishDraft","setAutoFreeze","proxyMap","proxySet","traps"],"mappings":"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"}