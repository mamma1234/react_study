{"version":3,"file":"immer.module.js","sources":["../src/types.ts","../src/common.ts","../src/scope.ts","../src/es5.ts","../src/proxy.ts","../src/patches.ts","../src/map.ts","../src/set.ts","../src/finalize.ts","../src/immer.ts","../src/index.ts"],"sourcesContent":["import {Nothing, DRAFT_STATE} from \"./common\"\nimport {SetState} from \"./set\"\nimport {MapState} from \"./map\"\nimport {ProxyObjectState, ProxyArrayState} from \"./proxy\"\nimport {ES5ObjectState, ES5ArrayState} from \"./es5\"\nimport {ImmerScope} from \"./scope\"\n\nexport type Objectish = AnyObject | AnyArray | AnyMap | AnySet\nexport type ObjectishNoSet = AnyObject | AnyArray | AnyMap\n\nexport type AnyObject = {[key: string]: any}\nexport type AnyArray = Array<any>\nexport type AnySet = Set<any>\nexport type AnyMap = Map<any, any>\nexport enum Archtype {\n\tObject,\n\tArray,\n\tMap,\n\tSet\n}\n\nexport enum ProxyType {\n\tProxyObject,\n\tProxyArray,\n\tES5Object,\n\tES5Array,\n\tMap,\n\tSet\n}\n\nexport interface ImmerBaseState {\n\tparent?: ImmerState\n\tscope: ImmerScope\n\tmodified: boolean\n\tfinalized: boolean\n\tisManual: boolean\n}\n\nexport type ImmerState =\n\t| ProxyObjectState\n\t| ProxyArrayState\n\t| ES5ObjectState\n\t| ES5ArrayState\n\t| MapState\n\t| SetState\n\n// The _internal_ type used for drafts (not to be confused with Draft, which is public facing)\nexport type Drafted<Base = any, T extends ImmerState = ImmerState> = {\n\t[DRAFT_STATE]: T\n} & Base\n\ntype Tail<T extends any[]> = ((...t: T) => any) extends (\n\t_: any,\n\t...tail: infer TT\n) => any\n\t? TT\n\t: []\n\n/** Object types that should never be mapped */\ntype AtomicObject =\n\t| Function\n\t| WeakMap<any, any>\n\t| WeakSet<any>\n\t| Promise<any>\n\t| Date\n\t| RegExp\n\t| Boolean\n\t| Number\n\t| String\n\nexport type Draft<T> = T extends AtomicObject\n\t? T\n\t: T extends Map<infer K, infer V>\n\t? DraftMap<K, V>\n\t: T extends Set<infer V>\n\t? DraftSet<V>\n\t: T extends object\n\t? {-readonly [K in keyof T]: Draft<T[K]>}\n\t: T\n\n// Inline these in ts 3.7\ninterface DraftMap<K, V> extends Map<Draft<K>, Draft<V>> {}\n\n// Inline these in ts 3.7\ninterface DraftSet<V> extends Set<Draft<V>> {}\n\n/** Convert a mutable type into a readonly type */\nexport type Immutable<T> = T extends AtomicObject\n\t? T\n\t: T extends Map<infer K, infer V> // Ideally, but wait for TS 3.7:    ? Omit<ImmutableMap<K, V>, \"set\" | \"delete\" | \"clear\">\n\t? ImmutableMap<K, V>\n\t: T extends Set<infer V> // Ideally, but wait for TS 3.7:    ? Omit<ImmutableSet<V>, \"add\" | \"delete\" | \"clear\">\n\t? ImmutableSet<V>\n\t: T extends object\n\t? {readonly [K in keyof T]: Immutable<T[K]>}\n\t: T\n\ninterface ImmutableMap<K, V> extends Map<Immutable<K>, Immutable<V>> {}\n\ninterface ImmutableSet<V> extends Set<Immutable<V>> {}\n\nexport interface Patch {\n\top: \"replace\" | \"remove\" | \"add\"\n\tpath: (string | number)[]\n\tvalue?: any\n}\n\nexport type PatchListener = (patches: Patch[], inversePatches: Patch[]) => void\n\n/** Converts `nothing` into `undefined` */\ntype FromNothing<T> = T extends Nothing ? undefined : T\n\n/** The inferred return type of `produce` */\nexport type Produced<Base, Return> = Return extends void\n\t? Base\n\t: Return extends Promise<infer Result>\n\t? Promise<Result extends void ? Base : FromNothing<Result>>\n\t: FromNothing<Return>\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport interface IProduce {\n\t/** Curried producer */\n\t<\n\t\tRecipe extends (...args: any[]) => any,\n\t\tParams extends any[] = Parameters<Recipe>,\n\t\tT = Params[0]\n\t>(\n\t\trecipe: Recipe\n\t): <Base extends Immutable<T>>(\n\t\tbase: Base,\n\t\t...rest: Tail<Params>\n\t) => Produced<Base, ReturnType<Recipe>>\n\t//   ^ by making the returned type generic, the actual type of the passed in object is preferred\n\t//     over the type used in the recipe. However, it does have to satisfy the immutable version used in the recipe\n\t//     Note: the type of S is the widened version of T, so it can have more props than T, but that is technically actually correct!\n\n\t/** Curried producer with initial state */\n\t<\n\t\tRecipe extends (...args: any[]) => any,\n\t\tParams extends any[] = Parameters<Recipe>,\n\t\tT = Params[0]\n\t>(\n\t\trecipe: Recipe,\n\t\tinitialState: Immutable<T>\n\t): <Base extends Immutable<T>>(\n\t\tbase?: Base,\n\t\t...rest: Tail<Params>\n\t) => Produced<Base, ReturnType<Recipe>>\n\n\t/** Normal producer */\n\t<Base, D = Draft<Base>, Return = void>(\n\t\tbase: Base,\n\t\trecipe: (draft: D) => Return,\n\t\tlistener?: PatchListener\n\t): Produced<Base, Return>\n}\n\n/**\n * Like `produce`, but instead of just returning the new state,\n * a tuple is returned with [nextState, patches, inversePatches]\n *\n * Like produce, this function supports currying\n */\nexport interface IProduceWithPatches {\n\t/** Curried producer */\n\t<\n\t\tRecipe extends (...args: any[]) => any,\n\t\tParams extends any[] = Parameters<Recipe>,\n\t\tT = Params[0]\n\t>(\n\t\trecipe: Recipe\n\t): <Base extends Immutable<T>>(\n\t\tbase: Base,\n\t\t...rest: Tail<Params>\n\t) => [Produced<Base, ReturnType<Recipe>>, Patch[], Patch[]]\n\t//   ^ by making the returned type generic, the actual type of the passed in object is preferred\n\t//     over the type used in the recipe. However, it does have to satisfy the immutable version used in the recipe\n\t//     Note: the type of S is the widened version of T, so it can have more props than T, but that is technically actually correct!\n\n\t/** Curried producer with initial state */\n\t<\n\t\tRecipe extends (...args: any[]) => any,\n\t\tParams extends any[] = Parameters<Recipe>,\n\t\tT = Params[0]\n\t>(\n\t\trecipe: Recipe,\n\t\tinitialState: Immutable<T>\n\t): <Base extends Immutable<T>>(\n\t\tbase?: Base,\n\t\t...rest: Tail<Params>\n\t) => [Produced<Base, ReturnType<Recipe>>, Patch[], Patch[]]\n\n\t/** Normal producer */\n\t<Base, D = Draft<Base>, Return = void>(\n\t\tbase: Base,\n\t\trecipe: (draft: D) => Return\n\t): [Produced<Base, Return>, Patch[], Patch[]]\n}\n","import {\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\tProxyType,\n\tArchtype\n} from \"./types\"\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n\nconst hasSymbol = typeof Symbol !== \"undefined\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\nexport const iteratorSymbol: typeof Symbol.iterator = hasSymbol\n\t? Symbol.iterator\n\t: (\"@@iterator\" as any)\n\n/** Returns true if the given value is an Immer draft */\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\treturn !proto || proto === Object.prototype\n}\n\n/** Get the underlying object that is represented by the given draft */\nexport function original<T>(value: Drafted<T>): T | undefined {\n\tif (value && value[DRAFT_STATE]) {\n\t\treturn value[DRAFT_STATE].base as any\n\t}\n\t// otherwise return undefined\n}\n\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void\n): void\nexport function each(obj: any, iter: any) {\n\tif (getArchtype(obj) === Archtype.Object) {\n\t\townKeys(obj).forEach(key => iter(key, obj[key], obj))\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\nexport function isEnumerable(base: AnyObject, prop: PropertyKey): boolean {\n\tconst desc = Object.getOwnPropertyDescriptor(base, prop)\n\treturn desc && desc.enumerable ? true : false\n}\n\nexport function getArchtype(thing: any): Archtype {\n\t/* istanbul ignore next */\n\tif (!thing) die()\n\tif (thing[DRAFT_STATE]) {\n\t\tswitch ((thing as Drafted)[DRAFT_STATE].type) {\n\t\t\tcase ProxyType.ES5Object:\n\t\t\tcase ProxyType.ProxyObject:\n\t\t\t\treturn Archtype.Object\n\t\t\tcase ProxyType.ES5Array:\n\t\t\tcase ProxyType.ProxyArray:\n\t\t\t\treturn Archtype.Array\n\t\t\tcase ProxyType.Map:\n\t\t\t\treturn Archtype.Map\n\t\t\tcase ProxyType.Set:\n\t\t\t\treturn Archtype.Set\n\t\t}\n\t}\n\treturn Array.isArray(thing)\n\t\t? Archtype.Array\n\t\t: isMap(thing)\n\t\t? Archtype.Map\n\t\t: isSet(thing)\n\t\t? Archtype.Set\n\t\t: Archtype.Object\n}\n\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === Archtype.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop]\n}\n\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tswitch (getArchtype(thing)) {\n\t\tcase Archtype.Map:\n\t\t\tthing.set(propOrOldValue, value)\n\t\t\tbreak\n\t\tcase Archtype.Set:\n\t\t\tthing.delete(propOrOldValue)\n\t\t\tthing.add(value)\n\t\t\tbreak\n\t\tdefault:\n\t\t\tthing[propOrOldValue] = value\n\t}\n}\n\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n\nexport function latest(state: ImmerState): any {\n\treturn state.copy || state.base\n}\n\nexport function shallowCopy<T extends AnyObject | AnyArray>(\n\tbase: T,\n\tinvokeGetters?: boolean\n): T\nexport function shallowCopy(base: any, invokeGetters = false) {\n\tif (Array.isArray(base)) return base.slice()\n\tconst clone = Object.create(Object.getPrototypeOf(base))\n\townKeys(base).forEach(key => {\n\t\tif (key === DRAFT_STATE) {\n\t\t\treturn // Never copy over draft state.\n\t\t}\n\t\tconst desc = Object.getOwnPropertyDescriptor(base, key)!\n\t\tlet {value} = desc\n\t\tif (desc.get) {\n\t\t\tif (!invokeGetters) {\n\t\t\t\tthrow new Error(\"Immer drafts cannot have computed properties\")\n\t\t\t}\n\t\t\tvalue = desc.get.call(base)\n\t\t}\n\t\tif (desc.enumerable) {\n\t\t\tclone[key] = value\n\t\t} else {\n\t\t\tObject.defineProperty(clone, key, {\n\t\t\t\tvalue,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true\n\t\t\t})\n\t\t}\n\t})\n\treturn clone\n}\n\nexport function freeze(obj: any, deep: boolean): void {\n\tif (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) return\n\tconst type = getArchtype(obj)\n\tif (type === Archtype.Set) {\n\t\tobj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t} else if (type === Archtype.Map) {\n\t\tobj.set = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (_, value) => freeze(value, true))\n}\n\nfunction dontMutateFrozenCollections() {\n\tthrow new Error(\"This object has been frozen and should not be mutated\")\n}\n\nexport function createHiddenProperty(\n\ttarget: AnyObject,\n\tprop: PropertyKey,\n\tvalue: any\n) {\n\tObject.defineProperty(target, prop, {\n\t\tvalue: value,\n\t\tenumerable: false,\n\t\twritable: true\n\t})\n}\n\n/* istanbul ignore next */\nexport function die(): never {\n\tthrow new Error(\"Illegal state, please file a bug\")\n}\n","import {DRAFT_STATE} from \"./common\"\nimport {Patch, PatchListener, Drafted, ProxyType} from \"./types\"\nimport {Immer} from \"./immer\"\n\n/** Each scope represents a `produce` call. */\nexport class ImmerScope {\n\tstatic current?: ImmerScope\n\n\tpatches?: Patch[]\n\tinversePatches?: Patch[]\n\tcanAutoFreeze: boolean\n\tdrafts: any[]\n\tparent?: ImmerScope\n\tpatchListener?: PatchListener\n\timmer: Immer\n\n\tconstructor(parent: ImmerScope | undefined, immer: Immer) {\n\t\tthis.drafts = []\n\t\tthis.parent = parent\n\t\tthis.immer = immer\n\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tthis.canAutoFreeze = true\n\t}\n\n\tusePatches(patchListener?: PatchListener) {\n\t\tif (patchListener) {\n\t\t\tthis.patches = []\n\t\t\tthis.inversePatches = []\n\t\t\tthis.patchListener = patchListener\n\t\t}\n\t}\n\n\trevoke() {\n\t\tthis.leave()\n\t\tthis.drafts.forEach(revoke)\n\t\t// @ts-ignore\n\t\tthis.drafts = null\n\t}\n\n\tleave() {\n\t\tif (this === ImmerScope.current) {\n\t\t\tImmerScope.current = this.parent\n\t\t}\n\t}\n\n\tstatic enter(immer: Immer) {\n\t\tconst scope = new ImmerScope(ImmerScope.current, immer)\n\t\tImmerScope.current = scope\n\t\treturn scope\n\t}\n}\n\nfunction revoke(draft: Drafted) {\n\tconst state = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type === ProxyType.ProxyObject ||\n\t\tstate.type === ProxyType.ProxyArray\n\t)\n\t\tstate.revoke()\n\telse state.revoked = true\n}\n","\"use strict\"\nimport {\n\teach,\n\thas,\n\tis,\n\tisDraft,\n\tisDraftable,\n\tisEnumerable,\n\tshallowCopy,\n\tDRAFT_STATE,\n\tlatest,\n\tcreateHiddenProperty\n} from \"./common\"\n\nimport {ImmerScope} from \"./scope\"\nimport {\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tObjectish,\n\tImmerBaseState,\n\tAnyArray,\n\tProxyType\n} from \"./types\"\nimport {MapState} from \"./map\"\nimport {SetState} from \"./set\"\n\ninterface ES5BaseState extends ImmerBaseState {\n\tfinalizing: boolean\n\tassigned: {[key: string]: any}\n\tparent?: ImmerState\n\trevoked: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype: ProxyType.ES5Object\n\tdraft: Drafted<AnyObject, ES5ObjectState>\n\tbase: AnyObject\n\tcopy: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype: ProxyType.ES5Array\n\tdraft: Drafted<AnyObject, ES5ArrayState>\n\tbase: AnyArray\n\tcopy: AnyArray | null\n}\n\ntype ES5State = ES5ArrayState | ES5ObjectState\n\nexport function willFinalizeES5(\n\tscope: ImmerScope,\n\tresult: any,\n\tisReplaced: boolean\n) {\n\tscope.drafts!.forEach(draft => {\n\t\tdraft[DRAFT_STATE].finalizing = true\n\t})\n\tif (!isReplaced) {\n\t\tif (scope.patches) {\n\t\t\tmarkChangesRecursively(scope.drafts![0])\n\t\t}\n\t\t// This is faster when we don't care about which attributes changed.\n\t\tmarkChangesSweep(scope.drafts)\n\t}\n\t// When a child draft is returned, look for changes.\n\telse if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n\t\tmarkChangesSweep(scope.drafts)\n\t}\n}\n\nexport function createES5Proxy<T>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ES5ObjectState | ES5ArrayState> {\n\tconst isArray = Array.isArray(base)\n\tconst draft = clonePotentialDraft(base)\n\n\teach(draft, prop => {\n\t\tproxyProperty(draft, prop, isArray || isEnumerable(base, prop))\n\t})\n\n\tconst state: ES5ObjectState | ES5ArrayState = {\n\t\ttype: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\n\t\tscope: parent ? parent.scope : ImmerScope.current!,\n\t\tmodified: false,\n\t\tfinalizing: false,\n\t\tfinalized: false,\n\t\tassigned: {},\n\t\tparent,\n\t\tbase,\n\t\tdraft,\n\t\tcopy: null,\n\t\trevoked: false,\n\t\tisManual: false\n\t}\n\n\tcreateHiddenProperty(draft, DRAFT_STATE, state)\n\treturn draft\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tif (state && !state.finalizing) {\n\t\tstate.finalizing = true\n\t\tconst value = draft[prop]\n\t\tstate.finalizing = false\n\t\treturn value\n\t}\n\treturn draft[prop]\n}\n\nfunction get(state: ES5State, prop: string | number) {\n\tassertUnrevoked(state)\n\tconst value = peek(latest(state), prop)\n\tif (state.finalizing) return value\n\t// Create a draft if the value is unmodified.\n\tif (value === peek(state.base, prop) && isDraftable(value)) {\n\t\tprepareCopy(state)\n\t\t// @ts-ignore\n\t\treturn (state.copy![prop] = state.scope.immer.createProxy(value, state))\n\t}\n\treturn value\n}\n\nfunction set(state: ES5State, prop: string | number, value: any) {\n\tassertUnrevoked(state)\n\tstate.assigned[prop] = true\n\tif (!state.modified) {\n\t\tif (is(value, peek(latest(state), prop))) return\n\t\tmarkChangedES5(state)\n\t\tprepareCopy(state)\n\t}\n\t// @ts-ignore\n\tstate.copy![prop] = value\n}\n\nexport function markChangedES5(state: ImmerState) {\n\tif (!state.modified) {\n\t\tstate.modified = true\n\t\tif (state.parent) markChangedES5(state.parent)\n\t}\n}\n\nfunction prepareCopy(state: ES5State) {\n\tif (!state.copy) state.copy = clonePotentialDraft(state.base)\n}\n\nfunction clonePotentialDraft(base: Objectish) {\n\tconst state = base && (base as any)[DRAFT_STATE]\n\tif (state) {\n\t\tstate.finalizing = true\n\t\tconst draft = shallowCopy(state.draft, true)\n\t\tstate.finalizing = false\n\t\treturn draft\n\t}\n\treturn shallowCopy(base)\n}\n\n// property descriptors are recycled to make sure we don't create a get and set closure per property,\n// but share them all instead\nconst descriptors: {[prop: string]: PropertyDescriptor} = {}\n\nfunction proxyProperty(\n\tdraft: Drafted<any, ES5State>,\n\tprop: string | number,\n\tenumerable: boolean\n) {\n\tlet desc = descriptors[prop]\n\tif (desc) {\n\t\tdesc.enumerable = enumerable\n\t} else {\n\t\tdescriptors[prop] = desc = {\n\t\t\tconfigurable: true,\n\t\t\tenumerable,\n\t\t\tget(this: any) {\n\t\t\t\treturn get(this[DRAFT_STATE], prop)\n\t\t\t},\n\t\t\tset(this: any, value) {\n\t\t\t\tset(this[DRAFT_STATE], prop, value)\n\t\t\t}\n\t\t}\n\t}\n\tObject.defineProperty(draft, prop, desc)\n}\n\nexport function assertUnrevoked(state: ES5State | MapState | SetState) {\n\tif (state.revoked === true)\n\t\tthrow new Error(\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\t\tJSON.stringify(latest(state))\n\t\t)\n}\n\n// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\nfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\n\t// The natural order of drafts in the `scope` array is based on when they\n\t// were accessed. By processing drafts in reverse natural order, we have a\n\t// better chance of processing leaf nodes first. When a leaf node is known to\n\t// have changed, we can avoid any traversal of its ancestor nodes.\n\tfor (let i = drafts.length - 1; i >= 0; i--) {\n\t\tconst state = drafts[i][DRAFT_STATE]\n\t\tif (!state.modified) {\n\t\t\tswitch (state.type) {\n\t\t\t\tcase ProxyType.ES5Array:\n\t\t\t\t\tif (hasArrayChanges(state)) markChangedES5(state)\n\t\t\t\t\tbreak\n\t\t\t\tcase ProxyType.ES5Object:\n\t\t\t\t\tif (hasObjectChanges(state)) markChangedES5(state)\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction markChangesRecursively(object: any) {\n\tif (!object || typeof object !== \"object\") return\n\tconst state = object[DRAFT_STATE]\n\tif (!state) return\n\tconst {base, draft, assigned, type} = state\n\tif (type === ProxyType.ES5Object) {\n\t\t// Look for added keys.\n\t\t// TODO: looks quite duplicate to hasObjectChanges,\n\t\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\n\t\t// unnecessary work.\n\t\t// also: probably we can store the information we detect here, to speed up tree finalization!\n\t\teach(draft, key => {\n\t\t\tif ((key as any) === DRAFT_STATE) return\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (base[key] === undefined && !has(base, key)) {\n\t\t\t\tassigned[key] = true\n\t\t\t\tmarkChangedES5(state)\n\t\t\t} else if (!assigned[key]) {\n\t\t\t\t// Only untouched properties trigger recursion.\n\t\t\t\tmarkChangesRecursively(draft[key])\n\t\t\t}\n\t\t})\n\t\t// Look for removed keys.\n\t\teach(base, key => {\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (draft[key] === undefined && !has(draft, key)) {\n\t\t\t\tassigned[key] = false\n\t\t\t\tmarkChangedES5(state)\n\t\t\t}\n\t\t})\n\t} else if (type === ProxyType.ES5Array && hasArrayChanges(state)) {\n\t\tmarkChangedES5(state)\n\t\tassigned.length = true\n\t\tif (draft.length < base.length) {\n\t\t\tfor (let i = draft.length; i < base.length; i++) assigned[i] = false\n\t\t} else {\n\t\t\tfor (let i = base.length; i < draft.length; i++) assigned[i] = true\n\t\t}\n\t\tfor (let i = 0; i < draft.length; i++) {\n\t\t\t// Only untouched indices trigger recursion.\n\t\t\tif (assigned[i] === undefined) markChangesRecursively(draft[i])\n\t\t}\n\t}\n}\n\nfunction hasObjectChanges(state: ES5ObjectState) {\n\tconst {base, draft} = state\n\n\t// Search for added keys and changed keys. Start at the back, because\n\t// non-numeric keys are ordered by time of definition on the object.\n\tconst keys = Object.keys(draft)\n\tfor (let i = keys.length - 1; i >= 0; i--) {\n\t\tconst key = keys[i]\n\t\tconst baseValue = base[key]\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (baseValue === undefined && !has(base, key)) {\n\t\t\treturn true\n\t\t}\n\t\t// Once a base key is deleted, future changes go undetected, because its\n\t\t// descriptor is erased. This branch detects any missed changes.\n\t\telse {\n\t\t\tconst value = draft[key]\n\t\t\tconst state = value && value[DRAFT_STATE]\n\t\t\tif (state ? state.base !== baseValue : !is(value, baseValue)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\n\t// At this point, no keys were added or changed.\n\t// Compare key count to determine if keys were deleted.\n\treturn keys.length !== Object.keys(base).length\n}\n\nfunction hasArrayChanges(state: ES5ArrayState) {\n\tconst {draft} = state\n\tif (draft.length !== state.base.length) return true\n\t// See #116\n\t// If we first shorten the length, our array interceptors will be removed.\n\t// If after that new items are added, result in the same original length,\n\t// those last items will have no intercepting property.\n\t// So if there is no own descriptor on the last position, we know that items were removed and added\n\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n\t// the last one\n\tconst descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1)\n\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\tif (descriptor && !descriptor.get) return true\n\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\treturn false\n}\n","\"use strict\"\nimport {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tDRAFT_STATE,\n\tlatest\n} from \"./common\"\nimport {ImmerScope} from \"./scope\"\nimport {\n\tAnyObject,\n\tDrafted,\n\tImmerState,\n\tAnyArray,\n\tObjectish,\n\tImmerBaseState,\n\tProxyType\n} from \"./types\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned: {\n\t\t[property: string]: boolean\n\t}\n\tparent?: ImmerState\n\tdrafts?: {\n\t\t[property: string]: Drafted<any, any>\n\t}\n\trevoke(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype: ProxyType.ProxyObject\n\tbase: AnyObject\n\tcopy: AnyObject | null\n\tdraft: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype: ProxyType.ProxyArray\n\tbase: AnyArray\n\tcopy: AnyArray | null\n\tdraft: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope: parent ? parent.scope : ImmerScope.current!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified: false,\n\t\t// Used during finalization.\n\t\tfinalized: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned: {},\n\t\t// The parent draft state.\n\t\tparent,\n\t\t// The base state.\n\t\tbase,\n\t\t// The base proxy.\n\t\tdraft: null as any, // set below\n\t\t// Any property proxies.\n\t\tdrafts: {},\n\t\t// The base copy with any updated values.\n\t\tcopy: null,\n\t\t// Called by the `produce` function.\n\t\trevoke: null as any,\n\t\tisManual: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\t// TODO: optimization: might be faster, cheaper if we created a non-revocable proxy\n\t// and administrate revoking ourselves\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft = proxy as any\n\tstate.revoke = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nconst objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\t\tlet {drafts} = state\n\n\t\t// Check for existing draft in unmodified state.\n\t\tif (!state.modified && has(drafts, prop)) {\n\t\t\treturn drafts![prop as any]\n\t\t}\n\n\t\tconst value = latest(state)[prop]\n\t\tif (state.finalized || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\n\t\t// Check for existing draft in modified state.\n\t\tif (state.modified) {\n\t\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\t\tif (value !== peek(state.base, prop)) return value\n\t\t\t// Store drafts on the copy (when one exists).\n\t\t\t// @ts-ignore\n\t\t\tdrafts = state.copy\n\t\t}\n\n\t\treturn (drafts![prop as any] = state.scope.immer.createProxy(value, state))\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(state, prop: string /* strictly not, but helps TS */, value) {\n\t\tif (!state.modified) {\n\t\t\tconst baseValue = peek(state.base, prop)\n\t\t\t// Optimize based on value's truthiness. Truthy values are guaranteed to\n\t\t\t// never be undefined, so we can avoid the `in` operator. Lastly, truthy\n\t\t\t// values may be drafts, but falsy values are never drafts.\n\t\t\tconst isUnchanged = value\n\t\t\t\t? is(baseValue, value) || value === state.drafts![prop]\n\t\t\t\t: is(baseValue, value) && prop in state.base\n\t\t\tif (isUnchanged) return true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\t\tstate.assigned[prop] = true\n\t\t// @ts-ignore\n\t\tstate.copy![prop] = value\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base, prop) !== undefined || prop in state.base) {\n\t\t\tstate.assigned[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else if (state.assigned[prop]) {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy) delete state.copy[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (desc) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable =\n\t\t\t\tstate.type !== ProxyType.ProxyArray || prop !== \"length\"\n\t\t}\n\t\treturn desc\n\t},\n\tdefineProperty() {\n\t\tthrow new Error(\"Object.defineProperty() cannot be used on an Immer draft\") // prettier-ignore\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base)\n\t},\n\tsetPrototypeOf() {\n\t\tthrow new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\") // prettier-ignore\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (isNaN(parseInt(prop as any))) {\n\t\tthrow new Error(\"Immer only supports deleting array indices\") // prettier-ignore\n\t}\n\treturn objectTraps.deleteProperty!.call(this, state[0], prop)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (prop !== \"length\" && isNaN(parseInt(prop as any))) {\n\t\tthrow new Error(\"Immer only supports setting array indices and the 'length' property\") // prettier-ignore\n\t}\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n/**\n * Map drafts\n */\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey): any {\n\tconst state = draft[DRAFT_STATE]\n\tconst desc = Reflect.getOwnPropertyDescriptor(\n\t\tstate ? latest(state) : draft,\n\t\tprop\n\t)\n\treturn desc && desc.value\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified) {\n\t\tstate.modified = true\n\t\tif (\n\t\t\tstate.type === ProxyType.ProxyObject ||\n\t\t\tstate.type === ProxyType.ProxyArray\n\t\t) {\n\t\t\tconst copy = (state.copy = shallowCopy(state.base))\n\t\t\teach(state.drafts!, (key, value) => {\n\t\t\t\t// @ts-ignore\n\t\t\t\tcopy[key] = value\n\t\t\t})\n\t\t\tstate.drafts = undefined\n\t\t}\n\n\t\tif (state.parent) {\n\t\t\tmarkChanged(state.parent)\n\t\t}\n\t}\n}\n\nfunction prepareCopy(state: ProxyState) {\n\tif (!state.copy) {\n\t\tstate.copy = shallowCopy(state.base)\n\t}\n}\n","import {get, each, isMap, has, die, getArchtype} from \"./common\"\nimport {Patch, ImmerState, ProxyType, Archtype} from \"./types\"\nimport {SetState} from \"./set\"\nimport {ES5ArrayState, ES5ObjectState} from \"./es5\"\nimport {ProxyArrayState, ProxyObjectState} from \"./proxy\"\nimport {MapState} from \"./map\"\n\nexport type PatchPath = (string | number)[]\n\nexport function generatePatches(\n\tstate: ImmerState,\n\tbasePath: PatchPath,\n\tpatches: Patch[],\n\tinversePatches: Patch[]\n): void {\n\tswitch (state.type) {\n\t\tcase ProxyType.ProxyObject:\n\t\tcase ProxyType.ES5Object:\n\t\tcase ProxyType.Map:\n\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\tstate,\n\t\t\t\tbasePath,\n\t\t\t\tpatches,\n\t\t\t\tinversePatches\n\t\t\t)\n\t\tcase ProxyType.ES5Array:\n\t\tcase ProxyType.ProxyArray:\n\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\tcase ProxyType.Set:\n\t\t\treturn generateSetPatches(\n\t\t\t\t(state as any) as SetState,\n\t\t\t\tbasePath,\n\t\t\t\tpatches,\n\t\t\t\tinversePatches\n\t\t\t)\n\t}\n}\n\nfunction generateArrayPatches(\n\tstate: ES5ArrayState | ProxyArrayState,\n\tbasePath: PatchPath,\n\tpatches: Patch[],\n\tinversePatches: Patch[]\n) {\n\tlet {base, assigned, copy} = state\n\t/* istanbul ignore next */\n\tif (!copy) die()\n\n\t// Reduce complexity by ensuring `base` is never longer.\n\tif (copy.length < base.length) {\n\t\t// @ts-ignore\n\t\t;[base, copy] = [copy, base]\n\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t}\n\n\tconst delta = copy.length - base.length\n\n\t// Find the first replaced index.\n\tlet start = 0\n\twhile (base[start] === copy[start] && start < base.length) {\n\t\t++start\n\t}\n\n\t// Find the last replaced index. Search from the end to optimize splice patches.\n\tlet end = base.length\n\twhile (end > start && base[end - 1] === copy[end + delta - 1]) {\n\t\t--end\n\t}\n\n\t// Process replaced indices.\n\tfor (let i = start; i < end; ++i) {\n\t\tif (assigned[i] && copy[i] !== base[i]) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: \"replace\",\n\t\t\t\tpath,\n\t\t\t\tvalue: copy[i]\n\t\t\t})\n\t\t\tinversePatches.push({\n\t\t\t\top: \"replace\",\n\t\t\t\tpath,\n\t\t\t\tvalue: base[i]\n\t\t\t})\n\t\t}\n\t}\n\n\tconst replaceCount = patches.length\n\n\t// Process added indices.\n\tfor (let i = end + delta - 1; i >= end; --i) {\n\t\tconst path = basePath.concat([i])\n\t\tpatches[replaceCount + i - end] = {\n\t\t\top: \"add\",\n\t\t\tpath,\n\t\t\tvalue: copy[i]\n\t\t}\n\t\tinversePatches.push({\n\t\t\top: \"remove\",\n\t\t\tpath\n\t\t})\n\t}\n}\n\n// This is used for both Map objects and normal objects.\nfunction generatePatchesFromAssigned(\n\tstate: MapState | ES5ObjectState | ProxyObjectState,\n\tbasePath: PatchPath,\n\tpatches: Patch[],\n\tinversePatches: Patch[]\n) {\n\tconst {base, copy} = state\n\teach(state.assigned!, (key, assignedValue) => {\n\t\tconst origValue = get(base, key)\n\t\tconst value = get(copy!, key)\n\t\tconst op = !assignedValue ? \"remove\" : has(base, key) ? \"replace\" : \"add\"\n\t\tif (origValue === value && op === \"replace\") return\n\t\tconst path = basePath.concat(key as any)\n\t\tpatches.push(op === \"remove\" ? {op, path} : {op, path, value})\n\t\tinversePatches.push(\n\t\t\top === \"add\"\n\t\t\t\t? {op: \"remove\", path}\n\t\t\t\t: op === \"remove\"\n\t\t\t\t? {op: \"add\", path, value: origValue}\n\t\t\t\t: {op: \"replace\", path, value: origValue}\n\t\t)\n\t})\n}\n\nfunction generateSetPatches(\n\tstate: SetState,\n\tbasePath: PatchPath,\n\tpatches: Patch[],\n\tinversePatches: Patch[]\n) {\n\tlet {base, copy} = state\n\n\tlet i = 0\n\tbase.forEach(value => {\n\t\tif (!copy!.has(value)) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: \"remove\",\n\t\t\t\tpath,\n\t\t\t\tvalue\n\t\t\t})\n\t\t\tinversePatches.unshift({\n\t\t\t\top: \"add\",\n\t\t\t\tpath,\n\t\t\t\tvalue\n\t\t\t})\n\t\t}\n\t\ti++\n\t})\n\ti = 0\n\tcopy!.forEach(value => {\n\t\tif (!base.has(value)) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: \"add\",\n\t\t\t\tpath,\n\t\t\t\tvalue\n\t\t\t})\n\t\t\tinversePatches.unshift({\n\t\t\t\top: \"remove\",\n\t\t\t\tpath,\n\t\t\t\tvalue\n\t\t\t})\n\t\t}\n\t\ti++\n\t})\n}\n\nexport function applyPatches<T>(draft: T, patches: Patch[]): T {\n\tpatches.forEach(patch => {\n\t\tconst {path, op} = patch\n\n\t\t/* istanbul ignore next */\n\t\tif (!path.length) die()\n\n\t\tlet base: any = draft\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tbase = get(base, path[i])\n\t\t\tif (!base || typeof base !== \"object\")\n\t\t\t\tthrow new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\")) // prettier-ignore\n\t\t}\n\n\t\tconst type = getArchtype(base)\n\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\tconst key = path[path.length - 1]\n\t\tswitch (op) {\n\t\t\tcase \"replace\":\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\tthrow new Error('Sets cannot have \"replace\" patches.')\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t}\n\t\t\tcase \"add\":\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\treturn base.splice(key as any, 0, value)\n\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t}\n\t\t\tcase \"remove\":\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unsupported patch operation: \" + op)\n\t\t}\n\t})\n\n\treturn draft\n}\n\n// TODO: optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n// E.g. auto-draft when new objects from outside are assigned and modified?\n// (See failing test when deepClone just returns obj)\nfunction deepClonePatchValue<T>(obj: T): T\nfunction deepClonePatchValue(obj: any) {\n\tif (!obj || typeof obj !== \"object\") return obj\n\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\tif (isMap(obj))\n\t\treturn new Map(\n\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t)\n\t// Not needed: if (isSet(obj)) return new Set(Array.from(obj.values()).map(deepClone))\n\tconst cloned = Object.create(Object.getPrototypeOf(obj))\n\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\treturn cloned\n}\n","import {isDraftable, DRAFT_STATE, latest, iteratorSymbol} from \"./common\"\n\nimport {ImmerScope} from \"./scope\"\nimport {AnyMap, Drafted, ImmerState, ImmerBaseState, ProxyType} from \"./types\"\nimport {assertUnrevoked} from \"./es5\"\n\nexport interface MapState extends ImmerBaseState {\n\ttype: ProxyType.Map\n\tcopy: AnyMap | undefined\n\tassigned: Map<any, boolean> | undefined\n\tbase: AnyMap\n\trevoked: boolean\n\tdraft: Drafted<AnyMap, MapState>\n}\n\n// Make sure DraftMap declarion doesn't die if Map is not avialable...\n/* istanbul ignore next */\nconst MapBase: MapConstructor =\n\ttypeof Map !== \"undefined\" ? Map : (function FakeMap() {} as any)\n\nexport class DraftMap<K, V> extends MapBase implements Map<K, V> {\n\t[DRAFT_STATE]: MapState\n\tconstructor(target: AnyMap, parent?: ImmerState) {\n\t\tsuper()\n\t\tthis[DRAFT_STATE] = {\n\t\t\ttype: ProxyType.Map,\n\t\t\tparent,\n\t\t\tscope: parent ? parent.scope : ImmerScope.current!,\n\t\t\tmodified: false,\n\t\t\tfinalized: false,\n\t\t\tcopy: undefined,\n\t\t\tassigned: undefined,\n\t\t\tbase: target,\n\t\t\tdraft: this,\n\t\t\tisManual: false,\n\t\t\trevoked: false\n\t\t}\n\t}\n\n\tget size(): number {\n\t\treturn latest(this[DRAFT_STATE]).size\n\t}\n\n\thas(key: K): boolean {\n\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t}\n\n\tset(key: K, value: V): this {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tif (latest(state).get(key) !== value) {\n\t\t\tprepareCopy(state)\n\t\t\tstate.scope.immer.markChanged(state)\n\t\t\tstate.assigned!.set(key, true)\n\t\t\tstate.copy!.set(key, value)\n\t\t\tstate.assigned!.set(key, true)\n\t\t}\n\t\treturn this\n\t}\n\n\tdelete(key: K): boolean {\n\t\tif (!this.has(key)) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tprepareCopy(state)\n\t\tstate.scope.immer.markChanged(state)\n\t\tstate.assigned!.set(key, false)\n\t\tstate.copy!.delete(key)\n\t\treturn true\n\t}\n\n\tclear() {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tprepareCopy(state)\n\t\tstate.scope.immer.markChanged(state)\n\t\tstate.assigned = new Map()\n\t\tfor (const key of latest(state).keys()) {\n\t\t\tstate.assigned.set(key, false)\n\t\t}\n\t\treturn state.copy!.clear()\n\t}\n\n\tforEach(cb: (value: V, key: K, self: this) => void, thisArg?: any) {\n\t\tconst state = this[DRAFT_STATE]\n\t\tlatest(state).forEach((_value: V, key: K, _map: this) => {\n\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t})\n\t}\n\n\tget(key: K): V {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tconst value = latest(state).get(key)\n\t\tif (state.finalized || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\tif (value !== state.base.get(key)) {\n\t\t\treturn value // either already drafted or reassigned\n\t\t}\n\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\tconst draft = state.scope.immer.createProxy(value, state)\n\t\tprepareCopy(state)\n\t\tstate.copy!.set(key, draft)\n\t\treturn draft\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\treturn latest(this[DRAFT_STATE]).keys()\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\tconst iterator = this.keys()\n\t\treturn {\n\t\t\t[iteratorSymbol]: () => this.values(),\n\t\t\tnext: () => {\n\t\t\t\tconst r = iterator.next()\n\t\t\t\t/* istanbul ignore next */\n\t\t\t\tif (r.done) return r\n\t\t\t\tconst value = this.get(r.value)\n\t\t\t\treturn {\n\t\t\t\t\tdone: false,\n\t\t\t\t\tvalue\n\t\t\t\t}\n\t\t\t}\n\t\t} as any\n\t}\n\n\tentries(): IterableIterator<[K, V]> {\n\t\tconst iterator = this.keys()\n\t\treturn {\n\t\t\t[iteratorSymbol]: () => this.entries(),\n\t\t\tnext: () => {\n\t\t\t\tconst r = iterator.next()\n\t\t\t\t/* istanbul ignore next */\n\t\t\t\tif (r.done) return r\n\t\t\t\tconst value = this.get(r.value)\n\t\t\t\treturn {\n\t\t\t\t\tdone: false,\n\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t}\n\t\t\t}\n\t\t} as any\n\t}\n\n\t[iteratorSymbol]() {\n\t\treturn this.entries()\n\t}\n}\n\nexport function proxyMap(target: AnyMap, parent?: ImmerState) {\n\treturn new DraftMap(target, parent)\n}\n\nfunction prepareCopy(state: MapState) {\n\tif (!state.copy) {\n\t\tstate.assigned = new Map()\n\t\tstate.copy = new Map(state.base)\n\t}\n}\n","import {DRAFT_STATE, latest, isDraftable, iteratorSymbol} from \"./common\"\n\nimport {ImmerScope} from \"./scope\"\nimport {AnySet, Drafted, ImmerState, ImmerBaseState, ProxyType} from \"./types\"\nimport {assertUnrevoked} from \"./es5\"\n\nexport interface SetState extends ImmerBaseState {\n\ttype: ProxyType.Set\n\tcopy: AnySet | undefined\n\tbase: AnySet\n\tdrafts: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked: boolean\n\tdraft: Drafted<AnySet, SetState>\n}\n\n// Make sure DraftSet declarion doesn't die if Map is not avialable...\n/* istanbul ignore next */\nconst SetBase: SetConstructor =\n\ttypeof Set !== \"undefined\" ? Set : (function FakeSet() {} as any)\n\nexport class DraftSet<K, V> extends SetBase implements Set<V> {\n\t[DRAFT_STATE]: SetState\n\tconstructor(target: AnySet, parent?: ImmerState) {\n\t\tsuper()\n\t\tthis[DRAFT_STATE] = {\n\t\t\ttype: ProxyType.Set,\n\t\t\tparent,\n\t\t\tscope: parent ? parent.scope : ImmerScope.current!,\n\t\t\tmodified: false,\n\t\t\tfinalized: false,\n\t\t\tcopy: undefined,\n\t\t\tbase: target,\n\t\t\tdraft: this,\n\t\t\tdrafts: new Map(),\n\t\t\trevoked: false,\n\t\t\tisManual: false\n\t\t}\n\t}\n\n\tget size(): number {\n\t\treturn latest(this[DRAFT_STATE]).size\n\t}\n\n\thas(value: V): boolean {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\tif (!state.copy) {\n\t\t\treturn state.base.has(value)\n\t\t}\n\t\tif (state.copy.has(value)) return true\n\t\tif (state.drafts.has(value) && state.copy.has(state.drafts.get(value)))\n\t\t\treturn true\n\t\treturn false\n\t}\n\n\tadd(value: V): this {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tif (state.copy) {\n\t\t\tstate.copy.add(value)\n\t\t} else if (!state.base.has(value)) {\n\t\t\tprepareCopy(state)\n\t\t\tstate.scope.immer.markChanged(state)\n\t\t\tstate.copy!.add(value)\n\t\t}\n\t\treturn this\n\t}\n\n\tdelete(value: V): boolean {\n\t\tif (!this.has(value)) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tprepareCopy(state)\n\t\tstate.scope.immer.markChanged(state)\n\t\treturn (\n\t\t\tstate.copy!.delete(value) ||\n\t\t\t(state.drafts.has(value)\n\t\t\t\t? state.copy!.delete(state.drafts.get(value))\n\t\t\t\t: /* istanbul ignore next */ false)\n\t\t)\n\t}\n\n\tclear() {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tprepareCopy(state)\n\t\tstate.scope.immer.markChanged(state)\n\t\treturn state.copy!.clear()\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tprepareCopy(state)\n\t\treturn state.copy!.values()\n\t}\n\n\tentries(): IterableIterator<[V, V]> {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tprepareCopy(state)\n\t\treturn state.copy!.entries()\n\t}\n\n\tkeys(): IterableIterator<V> {\n\t\treturn this.values()\n\t}\n\n\t[iteratorSymbol]() {\n\t\treturn this.values()\n\t}\n\n\tforEach(cb: (value: V, key: V, self: this) => void, thisArg?: any) {\n\t\tconst iterator = this.values()\n\t\tlet result = iterator.next()\n\t\twhile (!result.done) {\n\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\tresult = iterator.next()\n\t\t}\n\t}\n}\n\nexport function proxySet(target: AnySet, parent?: ImmerState) {\n\treturn new DraftSet(target, parent)\n}\n\nfunction prepareCopy(state: SetState) {\n\tif (!state.copy) {\n\t\t// create drafts for all entries to preserve insertion order\n\t\tstate.copy = new Set()\n\t\tstate.base.forEach(value => {\n\t\t\tif (isDraftable(value)) {\n\t\t\t\tconst draft = state.scope.immer.createProxy(value, state)\n\t\t\t\tstate.drafts.set(value, draft)\n\t\t\t\tstate.copy!.add(draft)\n\t\t\t} else {\n\t\t\t\tstate.copy!.add(value)\n\t\t\t}\n\t\t})\n\t}\n}\n","import {Immer} from \"./immer\"\nimport {ImmerState, Drafted, ProxyType} from \"./types\"\nimport {ImmerScope} from \"./scope\"\nimport {\n\tisSet,\n\thas,\n\tis,\n\tget,\n\teach,\n\tDRAFT_STATE,\n\tNOTHING,\n\tfreeze,\n\tshallowCopy,\n\tset\n} from \"./common\"\nimport {isDraft, isDraftable} from \"./index\"\nimport {SetState} from \"./set\"\nimport {generatePatches, PatchPath} from \"./patches\"\n\nexport function processResult(immer: Immer, result: any, scope: ImmerScope) {\n\tconst baseDraft = scope.drafts![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\timmer.willFinalize(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified) {\n\t\t\tscope.revoke()\n\t\t\tthrow new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\") // prettier-ignore\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(immer, result, scope)\n\t\t\tmaybeFreeze(immer, result)\n\t\t}\n\t\tif (scope.patches) {\n\t\t\tscope.patches.push({\n\t\t\t\top: \"replace\",\n\t\t\t\tpath: [],\n\t\t\t\tvalue: result\n\t\t\t})\n\t\t\tscope.inversePatches!.push({\n\t\t\t\top: \"replace\",\n\t\t\t\tpath: [],\n\t\t\t\tvalue: baseDraft[DRAFT_STATE].base\n\t\t\t})\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(immer, baseDraft, scope, [])\n\t}\n\tscope.revoke()\n\tif (scope.patches) {\n\t\tscope.patchListener!(scope.patches, scope.inversePatches!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(\n\timmer: Immer,\n\tdraft: Drafted,\n\tscope: ImmerScope,\n\tpath?: PatchPath\n) {\n\tconst state = draft[DRAFT_STATE]\n\tif (!state) {\n\t\tif (Object.isFrozen(draft)) return draft\n\t\treturn finalizeTree(immer, draft, scope)\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope !== scope) {\n\t\treturn draft\n\t}\n\tif (!state.modified) {\n\t\tmaybeFreeze(immer, state.base, true)\n\t\treturn state.base\n\t}\n\tif (!state.finalized) {\n\t\tstate.finalized = true\n\t\tfinalizeTree(immer, state.draft, scope, path)\n\n\t\t// We cannot really delete anything inside of a Set. We can only replace the whole Set.\n\t\tif (immer.onDelete && state.type !== ProxyType.Set) {\n\t\t\t// The `assigned` object is unreliable with ES5 drafts.\n\t\t\tif (immer.useProxies) {\n\t\t\t\tconst {assigned} = state\n\t\t\t\teach(assigned, (prop, exists) => {\n\t\t\t\t\tif (!exists) immer.onDelete!(state, prop as any)\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tconst {base, copy} = state\n\t\t\t\teach(base, prop => {\n\t\t\t\t\tif (!has(copy, prop)) immer.onDelete!(state, prop as any)\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tif (immer.onCopy) {\n\t\t\timmer.onCopy(state)\n\t\t}\n\n\t\t// At this point, all descendants of `state.copy` have been finalized,\n\t\t// so we can be sure that `scope.canAutoFreeze` is accurate.\n\t\tif (immer.autoFreeze && scope.canAutoFreeze) {\n\t\t\tfreeze(state.copy, false)\n\t\t}\n\n\t\tif (path && scope.patches) {\n\t\t\tgeneratePatches(state, path, scope.patches, scope.inversePatches!)\n\t\t}\n\t}\n\treturn state.copy\n}\n\nfunction finalizeTree(\n\timmer: Immer,\n\troot: Drafted,\n\tscope: ImmerScope,\n\trootPath?: PatchPath\n) {\n\tconst state = root[DRAFT_STATE]\n\tif (state) {\n\t\tif (\n\t\t\tstate.type === ProxyType.ES5Object ||\n\t\t\tstate.type === ProxyType.ES5Array\n\t\t) {\n\t\t\t// Create the final copy, with added keys and without deleted keys.\n\t\t\tstate.copy = shallowCopy(state.draft, true)\n\t\t}\n\t\troot = state.copy\n\t}\n\teach(root, (key, value) =>\n\t\tfinalizeProperty(immer, scope, root, state, root, key, value, rootPath)\n\t)\n\treturn root\n}\n\nfunction finalizeProperty(\n\timmer: Immer,\n\tscope: ImmerScope,\n\troot: Drafted,\n\trootState: ImmerState,\n\tparentValue: Drafted,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (childValue === parentValue) {\n\t\tthrow Error(\"Immer forbids circular references\")\n\t}\n\n\t// In the `finalizeTree` method, only the `root` object may be a draft.\n\tconst isDraftProp = !!rootState && parentValue === root\n\tconst isSetMember = isSet(parentValue)\n\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tisDraftProp &&\n\t\t\t!isSetMember && // Set objects are atomic since they have no keys.\n\t\t\t!has((rootState as Exclude<ImmerState, SetState>).assigned!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tchildValue = finalize(immer, childValue, scope, path)\n\t\tset(parentValue, prop, childValue)\n\n\t\t// Drafts from another scope must prevent auto-freezing.\n\t\tif (isDraft(childValue)) {\n\t\t\tscope.canAutoFreeze = false\n\t\t}\n\t}\n\t// Unchanged draft properties are ignored.\n\telse if (isDraftProp && is(childValue, get(rootState.base, prop))) {\n\t\treturn\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\t// TODO: the recursion over here looks weird, shouldn't non-draft stuff have it's own recursion?\n\t// especially the passing on of root and rootState doesn't make sense...\n\telse if (isDraftable(childValue) && !Object.isFrozen(childValue)) {\n\t\teach(childValue, (key, grandChild) =>\n\t\t\tfinalizeProperty(\n\t\t\t\timmer,\n\t\t\t\tscope,\n\t\t\t\troot,\n\t\t\t\trootState,\n\t\t\t\tchildValue,\n\t\t\t\tkey,\n\t\t\t\tgrandChild,\n\t\t\t\trootPath\n\t\t\t)\n\t\t)\n\t\tmaybeFreeze(immer, childValue)\n\t}\n\n\tif (isDraftProp && immer.onAssign && !isSetMember) {\n\t\timmer.onAssign(rootState, prop, childValue)\n\t}\n}\n\nexport function maybeFreeze(immer: Immer, value: any, deep = false) {\n\tif (immer.autoFreeze && !isDraft(value)) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {createES5Proxy, willFinalizeES5, markChangedES5} from \"./es5\"\nimport {createProxy, markChanged} from \"./proxy\"\n\nimport {applyPatches} from \"./patches\"\nimport {\n\teach,\n\tisDraft,\n\tisSet,\n\tisMap,\n\tisDraftable,\n\tDRAFT_STATE,\n\tNOTHING,\n\tdie\n} from \"./common\"\nimport {ImmerScope} from \"./scope\"\nimport {\n\tImmerState,\n\tIProduce,\n\tIProduceWithPatches,\n\tObjectish,\n\tPatchListener,\n\tDraft,\n\tPatch,\n\tDrafted\n} from \"./types\"\nimport {proxyMap} from \"./map\"\nimport {proxySet} from \"./set\"\nimport {processResult, maybeFreeze} from \"./finalize\"\n\n/* istanbul ignore next */\nfunction verifyMinified() {}\n\nconst configDefaults = {\n\tuseProxies:\n\t\ttypeof Proxy !== \"undefined\" &&\n\t\ttypeof Proxy.revocable !== \"undefined\" &&\n\t\ttypeof Reflect !== \"undefined\",\n\tautoFreeze:\n\t\ttypeof process !== \"undefined\"\n\t\t\t? process.env.NODE_ENV !== \"production\"\n\t\t\t: /* istanbul ignore next */\n\t\t\t  verifyMinified.name === \"verifyMinified\",\n\tonAssign: null,\n\tonDelete: null,\n\tonCopy: null\n} as const\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies: boolean = false\n\tautoFreeze: boolean = false\n\tonAssign?: (state: ImmerState, prop: string | number, value: unknown) => void\n\tonDelete?: (state: ImmerState, prop: string | number) => void\n\tonCopy?: (state: ImmerState) => void\n\n\tconstructor(config?: {\n\t\tuseProxies?: boolean\n\t\tautoFreeze?: boolean\n\t\tonAssign?: (\n\t\t\tstate: ImmerState,\n\t\t\tprop: string | number,\n\t\t\tvalue: unknown\n\t\t) => void\n\t\tonDelete?: (state: ImmerState, prop: string | number) => void\n\t\tonCopy?: (state: ImmerState) => void\n\t}) {\n\t\teach(configDefaults, (key, value) => {\n\t\t\t// @ts-ignore\n\t\t\tthis[key] = config?.[key] ?? value\n\t\t})\n\t\tthis.setUseProxies(this.useProxies)\n\t\tthis.produce = this.produce.bind(this)\n\t\tthis.produceWithPatches = this.produceWithPatches.bind(this)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce(base: any, recipe?: any, patchListener?: any) {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\t// prettier-ignore\n\t\t{\n\t\t\tif (typeof recipe !== \"function\") {\n\t\t\t\tthrow new Error(\"The first or second argument to `produce` must be a function\")\n\t\t\t}\n\t\t\tif (patchListener !== undefined && typeof patchListener !== \"function\") {\n\t\t\t\tthrow new Error(\"The third argument to `produce` must be a function or undefined\")\n\t\t\t}\n\t\t}\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = ImmerScope.enter(this)\n\t\t\tconst proxy = this.createProxy(base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) scope.revoke()\n\t\t\t\telse scope.leave()\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tscope.usePatches(patchListener)\n\t\t\t\t\t\treturn processResult(this, result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\tscope.revoke()\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tscope.usePatches(patchListener)\n\t\t\treturn processResult(this, result, scope)\n\t\t} else {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === NOTHING) return undefined\n\t\t\tif (result === undefined) result = base\n\t\t\tmaybeFreeze(this, result, true)\n\t\t\treturn result\n\t\t}\n\t}\n\n\tproduceWithPatches(arg1: any, arg2?: any, arg3?: any): any {\n\t\tif (typeof arg1 === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\n\t\t}\n\t\t// non-curried form\n\t\t/* istanbul ignore next */\n\t\tif (arg3) die()\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst nextState = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [nextState, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Drafted<T> {\n\t\tif (!isDraftable(base)) {\n\t\t\tthrow new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\") // prettier-ignore\n\t\t}\n\t\tconst scope = ImmerScope.enter(this)\n\t\tconst proxy = this.createProxy(base, undefined)\n\t\tproxy[DRAFT_STATE].isManual = true\n\t\tscope.leave()\n\t\treturn proxy\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && draft[DRAFT_STATE]\n\t\tif (!state || !state.isManual) {\n\t\t\tthrow new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\") // prettier-ignore\n\t\t}\n\t\tif (state.finalized) {\n\t\t\tthrow new Error(\"The given draft is already finalized\") // prettier-ignore\n\t\t}\n\t\tconst {scope} = state\n\t\tscope.usePatches(patchListener)\n\t\treturn processResult(this, undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is disabled in production.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tthis.useProxies = value\n\t}\n\n\tapplyPatches(base: Objectish, patches: Patch[]) {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatches(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatches(draft, patches.slice(i + 1))\n\t\t)\n\t}\n\n\tcreateProxy<T extends Objectish>(\n\t\tvalue: T,\n\t\tparent?: ImmerState\n\t): Drafted<T, ImmerState> {\n\t\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\t\tconst draft: Drafted = isMap(value)\n\t\t\t? proxyMap(value, parent)\n\t\t\t: isSet(value)\n\t\t\t? proxySet(value, parent)\n\t\t\t: this.useProxies\n\t\t\t? createProxy(value, parent)\n\t\t\t: createES5Proxy(value, parent)\n\n\t\tconst scope = parent ? parent.scope : ImmerScope.current!\n\t\tscope.drafts.push(draft)\n\t\treturn draft\n\t}\n\n\twillFinalize(scope: ImmerScope, thing: any, isReplaced: boolean) {\n\t\tif (!this.useProxies) willFinalizeES5(scope, thing, isReplaced)\n\t}\n\n\tmarkChanged(state: ImmerState) {\n\t\tif (this.useProxies) {\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\tmarkChangedES5(state)\n\t\t}\n\t}\n}\n","import {Immer} from \"./immer\"\nimport {IProduce, IProduceWithPatches} from \"./types\"\n\nexport {Draft, Immutable, Patch, PatchListener} from \"./types\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\nexport {\n\toriginal,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable\n} from \"./common\"\n\nexport {Immer}\n"],"names":["Archtype","ProxyType","const","hasSymbol","Symbol","hasMap","Map","hasSet","Set","NOTHING","DRAFTABLE","DRAFT_STATE","iteratorSymbol","iterator","isDraft","value","isDraftable","isPlainObject","Array","isArray","constructor","isMap","isSet","proto","Object","getPrototypeOf","prototype","original","base","ownKeys","Reflect","getOwnPropertySymbols","obj","getOwnPropertyNames","concat","each","iter","getArchtype","forEach","key","entry","index","isEnumerable","prop","desc","getOwnPropertyDescriptor","enumerable","thing","die","type","ES5Object","ProxyObject","ES5Array","ProxyArray","has","hasOwnProperty","call","get","set","propOrOldValue","delete","add","is","x","y","target","latest","state","copy","shallowCopy","invokeGetters","slice","clone","create","Error","defineProperty","writable","configurable","freeze","deep","isFrozen","clear","dontMutateFrozenCollections","_","createHiddenProperty","ImmerScope","parent","immer","drafts","canAutoFreeze","usePatches","patchListener","patches","inversePatches","revoke","leave","current","enter","scope","draft","revoked","willFinalizeES5","result","isReplaced","finalizing","markChangesRecursively","markChangesSweep","createES5Proxy","clonePotentialDraft","proxyProperty","modified","finalized","assigned","isManual","peek","assertUnrevoked","prepareCopy","createProxy","markChangedES5","descriptors","JSON","stringify","let","i","length","hasArrayChanges","hasObjectChanges","object","undefined","keys","baseValue","descriptor","traps","objectTraps","arrayTraps","Proxy","revocable","proxy","isUnchanged","markChanged","deleteProperty","owner","setPrototypeOf","fn","arguments","apply","isNaN","parseInt","generatePatches","basePath","generatePatchesFromAssigned","generateArrayPatches","generateSetPatches","delta","start","end","path","push","op","replaceCount","assignedValue","origValue","unshift","applyPatches","patch","join","deepClonePatchValue","splice","map","from","entries","v","k","cloned","MapBase","FakeMap","DraftMap","size","cb","thisArg","_value","_map","this","values","next","r","done","proxyMap","SetBase","FakeSet","DraftSet","proxySet","processResult","baseDraft","willFinalize","finalize","maybeFreeze","finalizeTree","onDelete","useProxies","exists","onCopy","autoFreeze","root","rootPath","finalizeProperty","rootState","parentValue","childValue","isDraftProp","isSetMember","grandChild","onAssign","verifyMinified","configDefaults","process","env","NODE_ENV","name","Immer","config","setUseProxies","produce","bind","produceWithPatches","recipe","defaultBase","self","curriedProduce","args","hasError","Promise","then","error","arg1","arg2","arg3","nextState","p","ip","createDraft","finishDraft","setAutoFreeze"],"mappings":"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"}